\chapter{Программный код плагина}\label{appendix-extra-examples}

Основной класс BuildConfigurationStatisticsAction.

\begin{lstlisting}[language=Java]
package io.jenkins.plugins.sample;

import com.google.gson.Gson;
import hudson.model.Action;
import hudson.model.Job;
import org.kohsuke.stapler.bind.JavaScriptMethod;

import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.text.ParseException;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Collectors;


public class BuildConfigurationStatisticsAction implements Action {
    private Job job;

    public BuildConfigurationStatisticsAction(Job job) {
        this.job = job;
    }

    @Override
    public String getIconFileName() {
        return "document.png";
    }

    @Override
    public String getDisplayName() {
        return "Build Configuration Statistics";
    }

    @Override
    public String getUrlName() {
        return "buildConfigurationStatistics";
    }

    public Job getJob() {
        return job;
    }

    @JavaScriptMethod
    public String getBuildDuration(String period, String fail, String statistics) throws ParseException {
        Logger LOGGER = Logger.getLogger("uuu");
        LOGGER.log(Level.INFO, "arg jelly: " + period);
        LOGGER.log(Level.INFO, "failed status: " + fail);
        LOGGER.log(Level.INFO, "statistics status: " + statistics);
        IntervalDate intreval = IntervalDate.valueOf(period);
        Statistics statisticsEnum = Statistics.valueOf(statistics);
        Boolean failed = fail.equals("1");
        //Boolean averageTime = average.equals("1");
        Gson gson = new Gson();
        Map<String, Double> map = new BuildDurationLogic(intreval, failed,job.getBuilds()).getBuildsDuration(statisticsEnum);
         String gsonData = gson.toJson(map);
        LOGGER.log(Level.INFO, "gson: " + gsonData);
        return gsonData;
    }
    @JavaScriptMethod
    public String getBuildSuccessRate(String period) throws ParseException {
        Logger LOGGER = Logger.getLogger("uuu1");
        LOGGER.log(Level.INFO, "arg jelly period success: " + period);
        IntervalDate intreval = IntervalDate.valueOf(period);
        Gson gson = new Gson();
        Map<String, Double> map = new BuildSuccessRateLogic(intreval,job.getBuilds()).getSuccessRate();
        String gsonData = gson.toJson(map);
        LOGGER.log(Level.INFO, "gson: " + gsonData);
        return gsonData;
    }

    @JavaScriptMethod
    public String getBuildArtifactSize(String period, String fail, String statistics) throws ParseException {
        Logger LOGGER = Logger.getLogger("artifact");
        LOGGER.log(Level.INFO, "arg jelly artifact: " + period);
        LOGGER.log(Level.INFO, "failed artifact: " + fail);
        LOGGER.log(Level.INFO, "statistics artifact: " + statistics);
        IntervalDate intreval = IntervalDate.valueOf(period);
        Statistics statisticsEnum = Statistics.valueOf(statistics);
        Boolean failed = fail.equals("1");
//        Boolean averageTime = average.equals("1");

        Gson gson = new Gson();
        Map<String, Double> map = new BuildArtifactSizeLogic(intreval, failed, job.getBuilds()).getArtifactSize(statisticsEnum);
        String gsonData = gson.toJson(map);
        LOGGER.log(Level.INFO, "gson artifact: " + gsonData);
        return gsonData;
    }

    @JavaScriptMethod
    public String getBuildTestCount(String period, String fail) throws ParseException {
        Logger LOGGER = Logger.getLogger("TestCount");
        LOGGER.log(Level.INFO, "arg jelly TestCount: " + period);
        LOGGER.log(Level.INFO, "failed TestCount: " + fail);
        IntervalDate intreval = IntervalDate.valueOf(period);
        Boolean failed = fail.equals("1");

        Gson gson = new Gson();
        Map<String, Integer> map = new BuildTestCountLogic(intreval, job.getBuilds()).getTestCount();
        String gsonData = gson.toJson(map);
        LOGGER.log(Level.INFO, "gson TestCount: " + gsonData);
        return gsonData;
    }

    @JavaScriptMethod
    public String getBuildTimeQueue(String period, String statistics) throws ParseException {
        Logger LOGGER = Logger.getLogger("queue");
        LOGGER.log(Level.INFO, "arg jelly queue: " + period);
        LOGGER.log(Level.INFO, "statistics queue: " + statistics);
        IntervalDate intreval = IntervalDate.valueOf(period);
        Statistics statisticsEnum = Statistics.valueOf(statistics);
//        Boolean averageTime = average.equals("1");

        Gson gson = new Gson();
        Map<String, Double> map = new BuildTimeQueueLogic(intreval, job.getBuilds()).getTimeQueue(statisticsEnum);
        String gsonData = gson.toJson(map);
        LOGGER.log(Level.INFO, "gson TimeQueue: " + gsonData);
        return gsonData;

    }

    @JavaScriptMethod
    public double getPredicted(String period, String metric) throws ParseException {
        Logger LOGGER = Logger.getLogger("getPredicted");
        LOGGER.log(Level.INFO, "getPredicted period: " + period);
        IntervalDate intreval = IntervalDate.valueOf(period);
        Map<String, Double> map;

        if (metric.equals("BD")) {
            map = new BuildDurationLogic(intreval, true,job.getBuilds()).getBuildsDuration(Statistics.AVG);
        } else {
            map = new BuildArtifactSizeLogic(intreval, true,job.getBuilds()).getArtifactSize(Statistics.AVG);
        }


        String formatDate;

        Map<Long, Double> newMap = new HashMap<Long, Double>();
        for(Map.Entry<String, Double> entry : map.entrySet()) {
            //LOGGER.log(Level.INFO, "map entrySet: " + map.entrySet());
            LOGGER.log(Level.INFO, "entrySet: " + entry.getKey() + " - " + entry.getValue());
            LOGGER.log(Level.INFO, "string date zero: " + DateTimeHandler.dateSetZeroDay(entry.getKey()));
            String parsedDate;
            if (intreval == IntervalDate.YEAR || intreval == IntervalDate.QUARTER) {
                parsedDate = DateTimeHandler.dateSetZeroDay(entry.getKey());
                formatDate = "yyyy-MM-dd";
            } else if (intreval == IntervalDate.DAY){
                parsedDate = entry.getKey();
                formatDate = "yyyy-MM-dd HH";
            }
            else {
                parsedDate = entry.getKey();
                formatDate = "yyyy-MM-dd";
            }

            LOGGER.log(Level.INFO, "string date: " + DateTimeHandler.convertStringToDate(parsedDate, formatDate));
            LOGGER.log(Level.INFO, "long time: " + DateTimeHandler.convertDateToLongTime(DateTimeHandler.convertStringToDate(parsedDate, formatDate)));
            newMap.put(DateTimeHandler.convertDateToLongTime(DateTimeHandler.convertStringToDate(parsedDate, formatDate)), entry.getValue());
        }
        LOGGER.log(Level.INFO, "newMap: " + newMap.keySet());
        SortedSet<Long> keys = new TreeSet<>(newMap.keySet());
        double[] listValuesMetric = new double[keys.size()];

        int i = 0;
        for (Long key : keys) {
            Double value = newMap.get(key);
            LOGGER.log(Level.INFO, "sorted key and value: " + key + " - " + value);
            // do something
            listValuesMetric[i] = value;
            LOGGER.log(Level.INFO, "listValuesMetric[i]: " + listValuesMetric[i]);
            LOGGER.log(Level.INFO, "listValuesMetric: " + Arrays.toString(listValuesMetric));
            i++;
        }
        LOGGER.log(Level.INFO, "listValuesMetric: " + Arrays.toString(listValuesMetric));
        double[] arrWeights = LinearRegressionHandler.calculateWeightMetric(listValuesMetric);
        LOGGER.log(Level.INFO, "arrWeights: " + Arrays.toString(arrWeights));
        LOGGER.log(Level.INFO, "listValuesMetric: " + Arrays.toString(listValuesMetric));
        double predictedNextValue = LinearRegressionHandler.linearRegression(listValuesMetric, arrWeights);

        DecimalFormatSymbols separator = new DecimalFormatSymbols();
        separator.setDecimalSeparator('.');

        DecimalFormat df = new DecimalFormat("#.##", separator);
        
        LOGGER.log(Level.INFO, "predictedNextValue format: " + df.format(predictedNextValue));
        predictedNextValue = Double.valueOf(df.format(predictedNextValue));

        return predictedNextValue;

    }
}



\end{lstlisting}

Класс для добавления действия BuildConfigurationStatisticsFactory.

\begin{lstlisting}[language=Java]
package io.jenkins.plugins.sample;

import hudson.Extension;
import hudson.model.Action;
import hudson.model.Job;
import java.util.Collection;
import java.util.Collections;
import javax.annotation.Nonnull;
import jenkins.model.TransientActionFactory;

@Extension
public class BuildConfigurationStatisticsFactory extends TransientActionFactory<Job> {
    @Override
    public Class<Job> type() {
        return Job.class;
    }

    @Nonnull
    @Override
    public Collection<? extends Action> createFor(@Nonnull Job job) {
        return Collections.singletonList(new BuildConfigurationStatisticsAction(job));
    }
}

\end{lstlisting}

Класс для обработки продолжительности сборки BuildDurationLogic.

\begin{lstlisting}[language=Java]
package io.jenkins.plugins.sample;

import hudson.model.AbstractBuild;
import hudson.model.Run;
import hudson.model.Queue;
import hudson.util.RunList;
import jenkins.model.Jenkins;

import java.io.IOException;
import java.text.ParseException;
import java.util.*;
import java.util.function.IntFunction;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
import hudson.model.AbstractBuild;
import org.apache.commons.math3.stat.StatUtils;
import org.apache.commons.math3.stat.descriptive.DescriptiveStatistics;
import org.apache.commons.math3.util.FastMath;

public class BuildDurationLogic extends BuildLogic {
    static Logger LOGGER = Logger.getLogger(BuildDurationLogic.class.getName());
    HashMap<String, List<Double>> dateFormatDuration;
    //HashMap<String, List<Double>> dateFormatDurationListValues;
    String dateFormatKey;

    public BuildDurationLogic(IntervalDate period, Boolean failed, RunList<Run> buildList) {
        super(period, failed, buildList);
    }

    public Map<String, Double> getBuildsDuration(Statistics statistics) throws ParseException {
        filterPeriodBuild();
        filterFailedBuild();
        switch (this.period){
            case MONTH:
                dateFormatDuration = DateTimeHandler.createDateMonthMap();
                //dateFormatDurationListValues = DateTimeHandler.createDateMonthMap();
                dateFormatKey = "yyyy-MM-dd";
                break;
            case WEEK:
                dateFormatDuration = DateTimeHandler.createDateWeekMap();
                dateFormatKey = "yyyy-MM-dd";
                break;
            case YEAR:
                dateFormatDuration = DateTimeHandler.createDateYearMap();
                dateFormatKey = "yyyy-MM";
                break;
            case QUARTER:
                dateFormatDuration = DateTimeHandler.createDateQuarterMap();
                dateFormatKey = "yyyy-MM";
                break;
            case DAY:
                dateFormatDuration = DateTimeHandler.createDateDayMap();
                dateFormatKey = "yyyy-MM-dd HH";
                break;
            case ALL:
                dateFormatDuration = DateTimeHandler.createDateAllMap(this.buildList);
                dateFormatKey = "yyyy-MM-dd";
                break;
        }


        //HashMap<String, Integer> dayDurationAverage = new HashMap<>();
        LOGGER.log(Level.WARNING, "buildList: " + (this.buildList));


        for (Run run : this.buildList) {
            String dateFormatKeyAfterCheckPeriod =
                    DateTimeHandler.dateToString(
                            DateTimeHandler.convertLongTimeToDate(
                                    run.getStartTimeInMillis()
                            ), dateFormatKey
                    );
            LOGGER.log(Level.INFO, "dateFormatKeyAfterCheckPeriod: " + dateFormatKeyAfterCheckPeriod);
            if (this.period == IntervalDate.DAY) {
                dateFormatKeyAfterCheckPeriod = DateTimeHandler.dateSetZeroMinutesSeconds(dateFormatKeyAfterCheckPeriod);
                LOGGER.log(Level.INFO, "dateFormatKeyAfterCheckPeriod for day zero: " + dateFormatKeyAfterCheckPeriod);
            }
//            if (dateFormatDuration.get(dateFormatKeyAfterCheckPeriod) == 0.0) {
//                dateFormatDuration.put(dateFormatKeyAfterCheckPeriod, run.getDuration() / 1000.0);
//                LOGGER.log(Level.WARNING, "getDuration: " + run.getDuration());
//                dayDurationAverage.put(dateFormatKeyAfterCheckPeriod, 1);
//            } else {
//                dateFormatDuration.put(dateFormatKeyAfterCheckPeriod, dateFormatDuration.get(dateFormatKeyAfterCheckPeriod) + run.getDuration() / 1000.0);
//                dayDurationAverage.put(dateFormatKeyAfterCheckPeriod, dayDurationAverage.get(dateFormatKeyAfterCheckPeriod) + 1);
//            }
            dateFormatDuration.get(dateFormatKeyAfterCheckPeriod).add(run.getDuration() / 1000.0);
            LOGGER.log(Level.WARNING, "dateFormatDurationListValues: " + dateFormatDuration);



        }

        HashMap<String, Double> dayDurationMetric = new HashMap<String, Double>();

        for (Map.Entry<String, List<Double>> entry : dateFormatDuration.entrySet()) {
            // work with one date array metric [1.2, 2.09, 5,09]
            DescriptiveStatistics descriptiveStatistics = new DescriptiveStatistics();
            for (double v : entry.getValue()) {
                descriptiveStatistics.addValue(v);
            }

            if (entry.getValue().size() == 0) {
                dayDurationMetric.put(entry.getKey(), 0.0);
                continue;
            }

            switch (statistics){
                case SUM:
                    double sum = descriptiveStatistics.getSum();
                    LOGGER.log(Level.WARNING, "sum: " + sum);
                    dayDurationMetric.put(entry.getKey(), sum);
                    break;
                case RANGE:
                    double range = descriptiveStatistics.getMax() - descriptiveStatistics.getMin();
                    //LOGGER.log(Level.WARNING, "range: " + range +"max"+ descriptiveStatistics.getMax() + "min" +descriptiveStatistics.getMin());
                    dayDurationMetric.put(entry.getKey(), range);
                    break;
                case AVG:
                    double mean = descriptiveStatistics.getMean();
                    LOGGER.log(Level.WARNING, "mean: " + mean);
                    dayDurationMetric.put(entry.getKey(), mean);
                    break;
                case MEDIAN:
                    double median = descriptiveStatistics.getPercentile(50);
                    LOGGER.log(Level.WARNING, "median: " + median);
                    dayDurationMetric.put(entry.getKey(), median);
                    break;
                case DISPERSION:
                    double dispersion = descriptiveStatistics.getPopulationVariance();
                    LOGGER.log(Level.WARNING, "sum: " + dispersion);
                    dayDurationMetric.put(entry.getKey(), dispersion);
                    break;
                case SDUNBIASED:
                    double sdUnbiased = descriptiveStatistics.getStandardDeviation();
                    LOGGER.log(Level.WARNING, "sdUnbiased: " + sdUnbiased);
                    dayDurationMetric.put(entry.getKey(), sdUnbiased);
                    break;
                case SD:
                    double sd = FastMath.sqrt(descriptiveStatistics.getPopulationVariance());
                    LOGGER.log(Level.WARNING, "sd: " + sd);
                    dayDurationMetric.put(entry.getKey(), sd);
                    break;
                case MODE:
                    //prepare for mode with StatUtils methods
                    double[] doublesArray = entry.getValue().stream().mapToDouble(d -> d).toArray();
                    double[] modes = StatUtils.mode(doublesArray);
                    double mode;

                    if (modes.length == doublesArray.length) {
                        mode = 0;
                    } else {
                        mode = modes[0];
                    }

                    LOGGER.log(Level.WARNING, "mode: " + mode);
                    dayDurationMetric.put(entry.getKey(), mode);
                    break;
            }


        }

        LOGGER.log(Level.INFO, "dayDurationMetric: " + dayDurationMetric);
        return dayDurationMetric;
    }
}






\end{lstlisting}

Класс для работы с датами и инициализации структур для метрик DateTimeHandler.

\begin{lstlisting}[language=Java]
package io.jenkins.plugins.sample;

import hudson.model.Run;
import hudson.util.RunList;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.*;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;

public class DateTimeHandler {

    static Logger LOGGER = Logger.getLogger(DateTimeHandler.class.getName());

    public static Date convertLongTimeToDate(long time) {
        Date date = new Date(time);
        return date;
    }

    public static Date convertStringToDate(String dateString, String format) throws ParseException {
        SimpleDateFormat formatter = new SimpleDateFormat(format);
        Date date = formatter.parse(dateString);
        return date;
    }



    /*
     * date format = yyyy MM dd HH:mm:ss
     *
     * */
    public static long convertDateToLongTime(Date date) throws ParseException {
        return date.getTime();
    }

    public static int getDayOfMonth(Date aDate) throws ParseException {
        Calendar cal = Calendar.getInstance();
        cal.setTime(aDate);
        return cal.get(Calendar.DAY_OF_MONTH);
    }

    public static int getCurrentMonthDays() {
        Calendar c = Calendar.getInstance();
        return c.getActualMaximum(Calendar.DAY_OF_MONTH);
    }

    public static int getLastMonthDays() {
        Calendar c = Calendar.getInstance();
        c.add(Calendar.MONTH, -1);
        return c.getActualMaximum(Calendar.DAY_OF_MONTH);
    }

//    public static int getLastMonths() {
//        Calendar c = Calendar.getInstance();
//        c.add(Calendar.MONTH, -1);
//        return c.getActualMaximum(Calendar.DAY_OF_MONTH);
//    }

    public static String dateToString(Date date, String format) {
        DateFormat dateFormat = new SimpleDateFormat(format);
        String strDate = dateFormat.format(date);
        return strDate;
    }

    public static String dateMonthToString(Date date) {
        DateFormat dateFormat = new SimpleDateFormat("yyyy-MM");
        String strDate = dateFormat.format(date);
        return strDate;
    }

    public static String dateSetZeroMinutesSeconds(String dateString) throws ParseException {

        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH");
        Date date = sdf.parse(dateString);
        Calendar cal = Calendar.getInstance();
        cal.setTime(date);
        cal.set(Calendar.MINUTE, 0);
        cal.set(Calendar.SECOND, 0);
        return dateToString(cal.getTime(), "yyyy-MM-dd HH:mm:ss");
    }

    public static String dateSetZeroDay(String dateString) throws ParseException {

        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM");
        Date date = sdf.parse(dateString);
        Calendar cal = Calendar.getInstance();
        cal.setTime(date);
        cal.set(Calendar.DAY_OF_MONTH, 1);
        return dateToString(cal.getTime(), "yyyy-MM-dd");
    }

    /**
     * Create map format {23.12: [], 24.12: [] ...}
     * on 30-31 days
     *
     * **/
    public static HashMap<String, List<Double>> createDateMonthMap() {
        ZonedDateTime dateTime = ZonedDateTime.now().minusMonths(1);
        Logger LOGGER;
        LOGGER = Logger.getLogger(DateTimeHandler.class.getName());
        LOGGER.log(Level.INFO, "dateTime" + dateTime);
        HashMap<String, List<Double>> dayDuration = new HashMap<String, List<Double>>();
        int lenMonth = getLastMonthDays();
        LOGGER.log(Level.INFO, "lenMonth: " + lenMonth);
        for (int i = 1; i <= lenMonth; i++) {

            DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
            String strDate = dateFormat.format(
                    Date.from(dateTime.plusDays(i).toInstant()).getTime());
            LOGGER.log(Level.INFO, "strdate i: " + i + " - " + strDate);
            dayDuration.put(strDate, new ArrayList<Double>());
            //dayDuration.get(strDate).add(0.0);
        }
        LOGGER.log(Level.INFO, "dayDuration: " + dayDuration.entrySet());
        return dayDuration;
    }


    /**
     * Create map format {23.12.2023: 0.0, 24.12.2023: 0.0 ...}
     * on 8 equal periods
     *
     * **/
    public static HashMap<String, List<Double>> createDateAllMap(RunList<Run> runs) {
        //ZonedDateTime dateTime = ZonedDateTime.now().minusMonths(1);
        Logger LOGGER;
        LOGGER = Logger.getLogger(DateTimeHandler.class.getName());
        LOGGER.log(Level.INFO, "run1" + runs.getFirstBuild());
        LOGGER.log(Level.INFO, "run2" + runs.getLastBuild());
        long timeStart = runs.getFirstBuild().getStartTimeInMillis();
        long timeEnd = runs.getLastBuild().getStartTimeInMillis();
        LocalDate startDate =
                LocalDate.ofInstant(Instant.ofEpochMilli(timeStart),
                        TimeZone.getDefault().toZoneId());
        LocalDate endDate =
                LocalDate.ofInstant(Instant.ofEpochMilli(timeEnd),
                        TimeZone.getDefault().toZoneId());
        Period period = Period.between(startDate, endDate);
        LOGGER.log(Level.INFO, "period between first and last build: " + period);
        HashMap<String, List<Double>> dayDuration = new HashMap<String, List<Double>>();
        int lenAll = 8;
        LOGGER.log(Level.INFO, "lenMonth: " + lenAll);
//        for (int i = 1; i <= lenAll; i++) {
//
//            DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
//            String strDate = dateFormat.format(
//                    Date.from(dateTime.plusDays(i).toInstant()).getTime());
//            LOGGER.log(Level.INFO, "strdate i: " + i + " - " + strDate);
//            dayDuration.put(strDate, 0.0);
//        }
        LOGGER.log(Level.INFO, "dayDuration: " + dayDuration.entrySet());
        return dayDuration;
    }

    /**
     * Create map format {1:00:00 0.0, 2:00:00: 0.0 ...}
     * on 24 hours
     *
     * **/
    public static HashMap<String, List<Double>> createDateDayMap() throws ParseException {
        ZonedDateTime dateTime = ZonedDateTime.now().minusHours(24);
        Logger LOGGER;
        LOGGER = Logger.getLogger(DateTimeHandler.class.getName());
        LOGGER.log(Level.INFO, "dateTime days" + dateTime);
        HashMap<String, List<Double>> hourDuration = new HashMap<String, List<Double>>();
        int lenDay = 24;
        LOGGER.log(Level.INFO, "lenDay: " + lenDay);
        for (int i = 1; i <= lenDay; i++) {

            DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            String strDate = dateFormat.format(
                    Date.from(dateTime.plusHours(i).toInstant()).getTime());
            strDate = DateTimeHandler.dateSetZeroMinutesSeconds(strDate);
            LOGGER.log(Level.INFO, "strdate i: " + i + " - " + strDate);
            hourDuration.put(strDate, new ArrayList<Double>());
            //hourDuration.put(strDate, 0.0);
        }
        LOGGER.log(Level.INFO, "hourDuration: " + hourDuration.entrySet());
        return hourDuration;
    }

    /**
     * Create map format {1:00:00 {success: 0, fail : 0}, 2:00:00: {success: 0, fail : 0} ...}
     * on 24 hours
     *
     * **/
    public static HashMap<String, HashMap<String,Integer>> createDateDayMapSuccess() throws ParseException {
        ZonedDateTime dateTime = ZonedDateTime.now().minusHours(24);
        Logger LOGGER;
        LOGGER = Logger.getLogger(DateTimeHandler.class.getName());
        LOGGER.log(Level.INFO, "dateTime days" + dateTime);
        HashMap<String, HashMap<String,Integer>> successFailSuccess = new HashMap();
        int lenDay = 24;
        LOGGER.log(Level.INFO, "lenDay: " + lenDay);
        for (int i = 1; i <= lenDay; i++) {

            DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            String strDate = dateFormat.format(
                    Date.from(dateTime.plusHours(i).toInstant()).getTime());
            strDate = DateTimeHandler.dateSetZeroMinutesSeconds(strDate);
            LOGGER.log(Level.INFO, "strdate i: " + i + " - " + strDate);
            successFailSuccess.put(strDate, new HashMap(){{
                put("fail", 0);
                put("success", 0);
            }});
        }
        LOGGER.log(Level.INFO, "hour successFailSuccess: " + successFailSuccess.entrySet());
        return successFailSuccess;
    }

    public static HashMap<String, HashMap<String,Integer>> createDateWeekMapSuccessRate() {
        ZonedDateTime dateTime = ZonedDateTime.now().minusWeeks(1);
        LOGGER.log(Level.INFO, "dateTime - 1 week" + dateTime);
        HashMap<String, HashMap<String,Integer>> successFailSuccess = new HashMap();
        int lenWeek = 7;
        LOGGER.log(Level.INFO, "lenWeek" + lenWeek);
        for (int i = 1; i <= lenWeek; i++) {

            DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
            //get dateTime previous week + i = 1...7 day and getTime, after in strDate=2022-03-22
            String strDate = dateFormat.format(
                    Date.from(dateTime.plusDays(i).toInstant()).getTime());
            LOGGER.log(Level.INFO, "strdate i: " + i + " - " + strDate);
            successFailSuccess.put(strDate, new HashMap(){{
                put("fail", 0);
                put("success", 0);
            }});
        }
        LOGGER.log(Level.INFO, "successFailSuccess: " + successFailSuccess.entrySet());
        return successFailSuccess;
    }
    /**
     * Create map format {23.12: {success: 0, fail : 0}, 24.12: {success: 0, fail : 0} ...}
     * on 30-31 days
     *
     * **/

    public static HashMap<String, HashMap<String,Integer>> createDateMonthMapSuccessRate() {
        ZonedDateTime dateTime = ZonedDateTime.now().minusMonths(1);
        LOGGER.log(Level.INFO, "dateTime" + dateTime);
        HashMap<String, HashMap<String,Integer>> successFailSuccess = new HashMap();
        int lenMonth = getLastMonthDays();
        LOGGER.log(Level.INFO, "lenMonth: " + lenMonth);
        for (int i = 1; i <= lenMonth; i++) {

            DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
            //get dateTime previous month + i = 1...31 day and getTime, after in strDate=2022-03-22
            String strDate = dateFormat.format(
                    Date.from(dateTime.plusDays(i).toInstant()).getTime());
            LOGGER.log(Level.INFO, "strdate i: " + i + " - " + strDate);
            successFailSuccess.put(strDate, new HashMap(){{
                put("fail", 0);
                put("success", 0);
            }});
        }
        LOGGER.log(Level.INFO, "successFailSuccess: " + successFailSuccess.entrySet());
        return successFailSuccess;
    }

    /**
     * Create map format {2/2022: {success: 0, fail : 0}, 3/2022: {success: 0, fail : 0} ...}
     * on 4 month
     *
     * **/

    public static HashMap<String, HashMap<String,Integer>> createDateQuarterMapSuccessRate() {
        ZonedDateTime dateTime = ZonedDateTime.now().minusMonths(3);
        LOGGER.log(Level.INFO, "dateTime QuarterMapSuccess" + dateTime);
        HashMap<String, HashMap<String,Integer>> successFailSuccess = new HashMap();
        int lenQuarterSuccess = 3;
        LOGGER.log(Level.INFO, "lenQuarterSuccess QuarterMapSuccess: " + lenQuarterSuccess);
        for (int i = 1; i <= lenQuarterSuccess; i++) {

            DateFormat dateFormat = new SimpleDateFormat("yyyy-MM");
            //get dateTime previous quarter + i = 1...4 month and getTime, after in strDate=2022-03
            String strDate = dateFormat.format(
                    Date.from(dateTime.plusMonths(i).toInstant()).getTime());
            LOGGER.log(Level.INFO, "strdate i: " + i + " - " + strDate);
            successFailSuccess.put(strDate, new HashMap(){{
                put("fail", 0);
                put("success", 0);
            }});
        }
        LOGGER.log(Level.INFO, "successFailSuccess: " + successFailSuccess.entrySet());
        return successFailSuccess;
    }

    /**
     * Create map format {23.12: 0, 24.12: 0 ...}
     * on 30-31 days
     *
     * **/

    public static HashMap<String, Integer> createDateMonthMapTestCount() {
        ZonedDateTime dateTime = ZonedDateTime.now().minusMonths(1);
        LOGGER.log(Level.INFO, "dateTime test count" + dateTime);
        HashMap<String, Integer> testCount = new HashMap();
        int lenMonth = getLastMonthDays();
        LOGGER.log(Level.INFO, "lenMonth test count: " + lenMonth);
        for (int i = 1; i <= lenMonth; i++) {

            DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
            //get dateTime previous month + i = 1...31 day and getTime, after in strDate=2022-03-22
            String strDate = dateFormat.format(
                    Date.from(dateTime.plusDays(i).toInstant()).getTime());
            LOGGER.log(Level.INFO, "strdate i: " + i + " - " + strDate);
            testCount.put(strDate, 0);
        }
        LOGGER.log(Level.INFO, "testCount: " + testCount.entrySet());
        return testCount;
    }

    /**
     * Create map format {12 10:00: 0, 12 11:00: 0 ...}
     * on 24 hours
     *
     * **/

    public static HashMap<String, Integer> createDateDayMapTestCount() throws ParseException {
        ZonedDateTime dateTime = ZonedDateTime.now().minusHours(24);
        Logger LOGGER;
        LOGGER = Logger.getLogger(DateTimeHandler.class.getName());
        LOGGER.log(Level.INFO, "dateTime days test count" + dateTime);
        HashMap<String, Integer> hourDuration = new HashMap<String, Integer>();
        int lenDay = 24;
        LOGGER.log(Level.INFO, "lenDay: " + lenDay);
        for (int i = 1; i <= lenDay; i++) {

            DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            String strDate = dateFormat.format(
                    Date.from(dateTime.plusHours(i).toInstant()).getTime());
            strDate = DateTimeHandler.dateSetZeroMinutesSeconds(strDate);
            LOGGER.log(Level.INFO, "strdate i: " + i + " - " + strDate);
            hourDuration.put(strDate, 0);
        }
        LOGGER.log(Level.INFO, "hourDuration: " + hourDuration.entrySet());
        return hourDuration;
    }

    /**
     * Create map format {2/2022: 0, 3/2022: 0 ...}
     * on 12 month
     *
     * **/
    public static HashMap<String, Integer> createDateYearMapTestCount() {
        ZonedDateTime dateTime = ZonedDateTime.now().minusYears(1);
        LOGGER.log(Level.INFO, "last year dateTime test" + dateTime);
        HashMap<String, Integer> monthDuration = new HashMap<String, Integer>();
        int lengthYear = 12; // any year length in month
        LOGGER.log(Level.INFO, "lengthYear test: " + lengthYear);
        for (int i = 1; i <= lengthYear; i++) {

            DateFormat dateFormat = new SimpleDateFormat("yyyy-MM");

            //get dateTime previous year + i = 1...12 and getTime, after in strDate=2022-03
            String strDate = dateFormat.format(
                    Date.from(
                            dateTime.plusMonths(i).toInstant()
                    ).getTime()
            );

            LOGGER.log(Level.INFO, "strdate i: " + i + " - " + strDate);
            monthDuration.put(strDate, 0);
        }
        LOGGER.log(Level.INFO, "monthDuration: " + monthDuration.entrySet());
        return monthDuration;
    }

    /**
     * Create map format {2/2022: 0, 3/2022: 0 ...}
     * on 3 month
     *
     * **/
    public static HashMap<String, Integer> createDateQuarterMapTestCount() {
        ZonedDateTime dateTime = ZonedDateTime.now().minusMonths(3);
        LOGGER.log(Level.INFO, "last quarter dateTime test" + dateTime);
        HashMap<String, Integer> quarterDuration = new HashMap<String, Integer>();
        int lengthQuarter = 3; // any year length in month
        LOGGER.log(Level.INFO, "lengthQuarter test: " + lengthQuarter);
        for (int i = 1; i <= lengthQuarter; i++) {

            DateFormat dateFormat = new SimpleDateFormat("yyyy-MM");

            //get dateTime previous year + i = 1...3 and getTime, after in strDate=2022-03
            String strDate = dateFormat.format(
                    Date.from(
                            dateTime.plusMonths(i).toInstant()
                    ).getTime()
            );

            LOGGER.log(Level.INFO, "strdate i test: " + i + " - " + strDate);
            quarterDuration.put(strDate, 0);
        }
        LOGGER.log(Level.INFO, "quarterDuration test: " + quarterDuration.entrySet());
        return quarterDuration;
    }

    /**
     * Create map format {1/2/2022: 0.0, 3/2/2022: 0.0 ...}
     * on 1 week
     *
     * **/
    public static HashMap<String, Integer> createDateWeekMapTestCount() {
        ZonedDateTime dateTime = ZonedDateTime.now().minusWeeks(1);
        LOGGER.log(Level.INFO, "last week dateTime test" + dateTime);
        HashMap<String, Integer> weekDuration = new HashMap<String, Integer>();
        int lengthWeek = 7; // any week length in days
        LOGGER.log(Level.INFO, "lengthWeek test: " + lengthWeek);
        for (int i = 1; i <= lengthWeek; i++) {

            DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");

            //get dateTime previous week + i = 1...7 and getTime, after in strDate=2022-03-01
            String strDate = dateFormat.format(
                    Date.from(
                            dateTime.plusDays(i).toInstant()
                    ).getTime()
            );

            LOGGER.log(Level.INFO, "strdate i test: " + i + " - " + strDate);
            weekDuration.put(strDate, 0);
        }
        LOGGER.log(Level.INFO, "weekDuration test: " + weekDuration.entrySet());
        return weekDuration;
    }


    /**
     * Create map format {2/2022: 0.0, 3/2022: 0.0 ...}
     * on 12 month
     *
     * **/
    public static HashMap<String, List<Double>> createDateYearMap() {
        ZonedDateTime dateTime = ZonedDateTime.now().minusYears(1);
        LOGGER.log(Level.INFO, "last year dateTime" + dateTime);
        HashMap<String, List<Double>> monthDuration = new HashMap<String, List<Double>>();
        int lengthYear = 12; // any year length in month
        LOGGER.log(Level.INFO, "lengthYear: " + lengthYear);
        for (int i = 1; i <= lengthYear; i++) {

            DateFormat dateFormat = new SimpleDateFormat("yyyy-MM");

            //get dateTime previous year + i = 1...12 and getTime, after in strDate=2022-03
            String strDate = dateFormat.format(
                    Date.from(
                            dateTime.plusMonths(i).toInstant()
                    ).getTime()
            );

            LOGGER.log(Level.INFO, "strdate i: " + i + " - " + strDate);
            monthDuration.put(strDate, new ArrayList<Double>());
        }
        LOGGER.log(Level.INFO, "monthDuration: " + monthDuration.entrySet());
        return monthDuration;
    }

    /**
     * Create map format {2/2022: 0.0, 3/2022: 0.0 ...}
     * on 3 month
     *
     * **/
    public static HashMap<String, List<Double>> createDateQuarterMap() {
        ZonedDateTime dateTime = ZonedDateTime.now().minusMonths(3);
        LOGGER.log(Level.INFO, "last quarter dateTime" + dateTime);
        HashMap<String, List<Double>> quarterDuration = new HashMap<String, List<Double>>();
        int lengthQuarter = 3; // any year length in month
        LOGGER.log(Level.INFO, "lengthQuarter: " + lengthQuarter);
        for (int i = 1; i <= lengthQuarter; i++) {

            DateFormat dateFormat = new SimpleDateFormat("yyyy-MM");

            //get dateTime previous year + i = 1...3 and getTime, after in strDate=2022-03
            String strDate = dateFormat.format(
                    Date.from(
                            dateTime.plusMonths(i).toInstant()
                    ).getTime()
            );

            LOGGER.log(Level.INFO, "strdate i: " + i + " - " + strDate);
            quarterDuration.put(strDate, new ArrayList<Double>());
        }
        LOGGER.log(Level.INFO, "quarterDuration: " + quarterDuration.entrySet());
        return quarterDuration;
    }

    /**
     * Create map format {1/2/2022: 0.0, 3/2/2022: 0.0 ...}
     * on 1 week
     *
     * **/
    public static HashMap<String, List<Double>> createDateWeekMap() {
        ZonedDateTime dateTime = ZonedDateTime.now().minusWeeks(1);
        LOGGER.log(Level.INFO, "last week dateTime duration" + dateTime);
        HashMap<String, List<Double>> weekDuration = new HashMap<String, List<Double>>();
        int lengthWeek = 7; // any week length in days
        LOGGER.log(Level.INFO, "lengthWeek: " + lengthWeek);
        for (int i = 1; i <= lengthWeek; i++) {

            DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");

            //get dateTime previous week + i = 1...7 and getTime, after in strDate=2022-03-01
            String strDate = dateFormat.format(
                    Date.from(
                            dateTime.plusDays(i).toInstant()
                    ).getTime()
            );

            LOGGER.log(Level.INFO, "strdate i: " + i + " - " + strDate);
            weekDuration.put(strDate, new ArrayList<Double>());
        }
        LOGGER.log(Level.INFO, "weekDuration: " + weekDuration.entrySet());
        return weekDuration;
    }

    public static HashMap<String, HashMap<String,Integer>> createDateYearMapSuccessRate() {
        ZonedDateTime dateTime = ZonedDateTime.now().minusYears(1);
        LOGGER.log(Level.INFO, "last year dateTime success" + dateTime);
        HashMap<String, HashMap<String,Integer>> successFailSuccess = new HashMap();
        int lenMonth = 12;
        LOGGER.log(Level.INFO, "lenMonth: " + lenMonth);
        for (int i = 1; i <= lenMonth; i++) {

            DateFormat dateFormat = new SimpleDateFormat("yyyy-MM");
            //get dateTime previous year + i = 1...12 and getTime, after in strDate=2022-03
            String strDate = dateFormat.format(
                    Date.from(dateTime.plusMonths(i).toInstant()).getTime());
            LOGGER.log(Level.INFO, "strdate i: " + i + " - " + strDate);
            successFailSuccess.put(strDate, new HashMap(){{
                put("fail", 0);
                put("success", 0);
            }});
        }
        LOGGER.log(Level.INFO, "successFailSuccess: " + successFailSuccess.entrySet());
        return successFailSuccess;
    }
}








\end{lstlisting}

Код BuildLogic.java:

\begin{lstlisting}

package io.jenkins.plugins.sample;

import hudson.model.Result;
import hudson.model.Run;
import hudson.util.RunList;
import java.text.ParseException;
import java.time.ZonedDateTime;
import java.util.Date;
import java.util.logging.Level;
import java.util.logging.Logger;

public class BuildLogic {
    IntervalDate period;
    RunList<Run> buildList;

    Boolean failed;
    static Logger LOGGER = Logger.getLogger(BuildLogic.class.getName());


    public BuildLogic(IntervalDate period, Boolean failed, RunList<Run> buildList) {
        this.period = period;
        this.buildList = buildList;
        this.failed = failed;
    }

    public void filterPeriodBuild() {
        switch (period) {
            case MONTH:
                Date dateMonth = Date.from(ZonedDateTime.now().minusMonths(1).toInstant());
                this.buildList = buildList.filter(run -> {
                    try {
                        return run.getStartTimeInMillis() >= DateTimeHandler.convertDateToLongTime(dateMonth);
                    } catch (ParseException e) {
                        throw new RuntimeException(e);
                    }
                });
                break;
            case YEAR:
                Date dateYear = Date.from(ZonedDateTime.now().minusYears(1).toInstant());
                this.buildList = buildList.filter(run -> {
                    try {
                        return run.getStartTimeInMillis() >= DateTimeHandler.convertDateToLongTime(dateYear);
                    } catch (ParseException e) {
                        throw new RuntimeException(e);
                    }
                });
                break;
            case DAY:
                Date dateDay = Date.from(ZonedDateTime.now().minusHours(24).toInstant());
                this.buildList = buildList.filter(run -> {
                    try {
                        LOGGER.log(Level.WARNING, "runTime: " + DateTimeHandler.convertLongTimeToDate(run.getStartTimeInMillis()));
                        LOGGER.log(Level.WARNING, "runTime: " + run.getStartTimeInMillis() + "now " + DateTimeHandler.convertDateToLongTime(dateDay));
                        LOGGER.log(Level.WARNING, "bool check: " + (run.getStartTimeInMillis() >= DateTimeHandler.convertDateToLongTime(dateDay)));
                        return run.getStartTimeInMillis() >= DateTimeHandler.convertDateToLongTime(dateDay);
                    } catch (ParseException e) {
                        throw new RuntimeException(e);
                    }
                });
                LOGGER.log(Level.WARNING, "dat filter: " + (this.buildList));
                break;
            case WEEK:
                Date dateWeek = Date.from(ZonedDateTime.now().minusDays(6).toInstant());
                this.buildList = buildList.filter(run -> {
                    try {
                        return run.getStartTimeInMillis() >= DateTimeHandler.convertDateToLongTime(dateWeek);
                    } catch (ParseException e) {
                        throw new RuntimeException(e);
                    }
                });
                break;
            case QUARTER:
                Date dateQuarter = Date.from(ZonedDateTime.now().minusMonths(3).toInstant());
                this.buildList = buildList.filter(run -> {
                    try {
                        return run.getStartTimeInMillis() >= DateTimeHandler.convertDateToLongTime(dateQuarter);
                    } catch (ParseException e) {
                        throw new RuntimeException(e);
                    }
                });
                break;
            case ALL:
                break;
        }
    }

    public void filterFailedBuild() {
        if (!failed) {
            this.buildList = buildList.filter(run -> {
                return run.getResult().isBetterOrEqualTo(Result.SUCCESS);
            });
        }
    }
}


\end{lstlisting}

Код BuildArtifactSizeLogic.java:

\begin{lstlisting}

package io.jenkins.plugins.sample;

import hudson.model.Run;
import hudson.util.RunList;
import org.apache.commons.math3.stat.StatUtils;
import org.apache.commons.math3.stat.descriptive.DescriptiveStatistics;
import org.apache.commons.math3.util.FastMath;

import java.text.ParseException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

public class BuildArtifactSizeLogic extends BuildLogic {

    static Logger LOGGER = Logger.getLogger(BuildDurationLogic.class.getName());
    HashMap<String, List<Double>> dateFormatArtifact;
    String dateFormatKey;
    public BuildArtifactSizeLogic(IntervalDate period, Boolean failed, RunList<Run> buildList) {
        super(period, failed,buildList);
    }

    public Map<String, Double> getArtifactSize(Statistics statistics) throws ParseException {
        filterPeriodBuild();
        filterFailedBuild();
        switch (this.period){
            case MONTH:
                dateFormatArtifact = DateTimeHandler.createDateMonthMap();
                dateFormatKey = "yyyy-MM-dd";
                break;
            case WEEK:
                dateFormatArtifact = DateTimeHandler.createDateWeekMap();
                dateFormatKey = "yyyy-MM-dd";
                break;
            case YEAR:
                dateFormatArtifact = DateTimeHandler.createDateYearMap();
                dateFormatKey = "yyyy-MM";
                break;
            case QUARTER:
                dateFormatArtifact = DateTimeHandler.createDateQuarterMap();
                dateFormatKey = "yyyy-MM";
                break;
            case DAY:
                dateFormatArtifact = DateTimeHandler.createDateDayMap();
                dateFormatKey = "yyyy-MM-dd HH";
                break;
            case ALL:
                dateFormatArtifact = DateTimeHandler.createDateYearMap();
                dateFormatKey = "yyyy-MM";
                break;
        }


//        HashMap<String, Integer> dayArtifactAverage = new HashMap<>();
        for (Run run : this.buildList) {
            String dateFormatKeyAfterCheckPeriod =
                    DateTimeHandler.dateToString(
                            DateTimeHandler.convertLongTimeToDate(
                                    run.getStartTimeInMillis()
                            ), dateFormatKey
                    );
            LOGGER.log(Level.INFO, "dateFormatKeyAfterCheckPeriod artifact: " + dateFormatKeyAfterCheckPeriod);
            if (this.period == IntervalDate.DAY) {
                dateFormatKeyAfterCheckPeriod = DateTimeHandler.dateSetZeroMinutesSeconds(dateFormatKeyAfterCheckPeriod);
                LOGGER.log(Level.INFO, "dateFormatKeyAfterCheckPeriod for day zero: " + dateFormatKeyAfterCheckPeriod);
            }
            LOGGER.log(Level.WARNING, "getArtifacts: " + run.getArtifacts());
            List<Run.Artifact> listArtifacts = run.getArtifacts();
            double artifactsRunSize = 0;

            for (Run.Artifact artifact : listArtifacts) {
                artifactsRunSize += artifact.getFileSize()/1024.0;
                LOGGER.log(Level.WARNING, "artifact.getFileSize(): " +artifact.getFileSize());
            }

            LOGGER.log(Level.WARNING, "artifactsRunSize: " + artifactsRunSize);

//            if (dateFormatArtifact.get(dateFormatKeyAfterCheckPeriod) == 0.0) {
//                dateFormatArtifact.put(dateFormatKeyAfterCheckPeriod, artifactsRunSize);
//                dayArtifactAverage.put(dateFormatKeyAfterCheckPeriod, 1);
//            } else {
//                dateFormatArtifact.put(dateFormatKeyAfterCheckPeriod, dateFormatArtifact.get(dateFormatKeyAfterCheckPeriod) + artifactsRunSize);
//                dayArtifactAverage.put(dateFormatKeyAfterCheckPeriod, dayArtifactAverage.get(dateFormatKeyAfterCheckPeriod) + 1);
//            }
            dateFormatArtifact.get(dateFormatKeyAfterCheckPeriod).add(artifactsRunSize);
            LOGGER.log(Level.WARNING, "dateFormatArtifact: " + dateFormatArtifact);
        }


        HashMap<String, Double> dayArtifactMetric = new HashMap<String, Double>();

        for (Map.Entry<String, List<Double>> entry : dateFormatArtifact.entrySet()) {
            // work with one date array metric [1.2, 2.09, 5,09]
            DescriptiveStatistics descriptiveStatistics = new DescriptiveStatistics();
            for (double v : entry.getValue()) {
                descriptiveStatistics.addValue(v);
            }

            if (entry.getValue().size() == 0) {
                dayArtifactMetric.put(entry.getKey(), 0.0);
                continue;
            }

            switch (statistics){
                case SUM:
                    double sum = descriptiveStatistics.getSum();
                    LOGGER.log(Level.WARNING, "sum: " + sum);
                    dayArtifactMetric.put(entry.getKey(), sum);
                    break;
                case AVG:
                    double mean = descriptiveStatistics.getMean();
                    LOGGER.log(Level.WARNING, "mean: " + mean);
                    dayArtifactMetric.put(entry.getKey(), mean);
                    break;
                case RANGE:
                    double range = descriptiveStatistics.getMax() - descriptiveStatistics.getMin();
                    LOGGER.log(Level.WARNING, "range: " + range);
                    dayArtifactMetric.put(entry.getKey(), range);
                    break;
                case MEDIAN:
                    double median = descriptiveStatistics.getPercentile(50);
                    LOGGER.log(Level.WARNING, "median: " + median);
                    dayArtifactMetric.put(entry.getKey(), median);
                    break;
                case DISPERSION:
                    double dispersion = descriptiveStatistics.getPopulationVariance();
                    LOGGER.log(Level.WARNING, "sum: " + dispersion);
                    dayArtifactMetric.put(entry.getKey(), dispersion);
                    break;
                case SDUNBIASED:
                    double sdUnbiased = descriptiveStatistics.getStandardDeviation();
                    LOGGER.log(Level.WARNING, "sdUnbiased: " + sdUnbiased);
                    dayArtifactMetric.put(entry.getKey(), sdUnbiased);
                    break;
                case SD:
                    double sd = FastMath.sqrt(descriptiveStatistics.getPopulationVariance());
                    LOGGER.log(Level.WARNING, "sd: " + sd);
                    dayArtifactMetric.put(entry.getKey(), sd);
                    break;
                case MODE:
                    //prepare for mode with StatUtils methods
                    double[] doublesArray = entry.getValue().stream().mapToDouble(d -> d).toArray();
                    double[] modes = StatUtils.mode(doublesArray);
                    double mode;

                    if (modes.length == doublesArray.length) {
                        mode = 0;
                    } else {
                        mode = modes[0];
                    }

                    LOGGER.log(Level.WARNING, "mode: " + mode);
                    dayArtifactMetric.put(entry.getKey(), mode);
                    break;
            }


        }

//        if (average) {
//            for (Map.Entry<String, Integer> entry : dayArtifactAverage.entrySet()) {
//                LOGGER.log(Level.INFO, "sum time duration: " + dateFormatArtifact.get(entry.getKey()));
//                LOGGER.log(Level.INFO, "count runs: " + entry.getValue());
//                dateFormatArtifact.put(entry.getKey(),
//                        dateFormatArtifact.get(entry.getKey())/entry.getValue()
//                );
//            }
//        }
        LOGGER.log(Level.INFO, "dayArtifactMetric: " + dayArtifactMetric);
//        LOGGER.log(Level.INFO, "dayArtifactAverage: " + dayArtifactAverage);
        return dayArtifactMetric;
    }
}



\end{lstlisting}

Код BuildSuccessRateLogic.java:

\begin{lstlisting}
package io.jenkins.plugins.sample;

import hudson.model.Result;
import hudson.model.Run;
import hudson.util.RunList;
import java.text.ParseException;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

public class BuildSuccessRateLogic extends BuildLogic {

    static Logger LOGGER = Logger.getLogger(BuildSuccessRateLogic.class.getName());
    HashMap<String, HashMap<String,Integer>> successRateOnFormatDate;
    String dateFormatKey;

    public BuildSuccessRateLogic(IntervalDate period, RunList<Run> buildList) {
        super(period,false, buildList);
    }


    public Map<String, Double> getSuccessRate() throws ParseException {
        filterPeriodBuild();
        switch (this.period){
            case MONTH:
                successRateOnFormatDate = DateTimeHandler.createDateMonthMapSuccessRate();
                dateFormatKey = "yyyy-MM-dd";
                break;
            case WEEK:
                successRateOnFormatDate = DateTimeHandler.createDateWeekMapSuccessRate();
                dateFormatKey = "yyyy-MM-dd";
                break;
            case YEAR:
                successRateOnFormatDate = DateTimeHandler.createDateYearMapSuccessRate();
                dateFormatKey = "yyyy-MM";
                break;
            case QUARTER:
                successRateOnFormatDate = DateTimeHandler.createDateQuarterMapSuccessRate();
                dateFormatKey = "yyyy-MM";
                break;
            case DAY:
                successRateOnFormatDate = DateTimeHandler.createDateDayMapSuccess();
                dateFormatKey = "yyyy-MM-dd HH";
                break;
            case ALL:
                successRateOnFormatDate = DateTimeHandler.createDateWeekMapSuccessRate();
                dateFormatKey = "yyyy-MM";
                break;
        }

        for (Run run : this.buildList) {
            String dateFormatKeyAfterCheckPeriod =
                    DateTimeHandler.dateToString(
                            DateTimeHandler.convertLongTimeToDate(
                                    run.getStartTimeInMillis()
                            ), dateFormatKey
                    );
            LOGGER.log(Level.INFO, "dateFormatKeyAfterCheckPeriod: " + dateFormatKeyAfterCheckPeriod);
            if (this.period == IntervalDate.DAY) {
                dateFormatKeyAfterCheckPeriod = DateTimeHandler.dateSetZeroMinutesSeconds(dateFormatKeyAfterCheckPeriod);
                LOGGER.log(Level.INFO, "dateFormatKeyAfterCheckPeriod for day zero: " + dateFormatKeyAfterCheckPeriod);
            }
            if (run.getResult().isBetterOrEqualTo(Result.SUCCESS)){
                successRateOnFormatDate.get(dateFormatKeyAfterCheckPeriod).put("success", (successRateOnFormatDate.get(dateFormatKeyAfterCheckPeriod).get("success")) + 1);
            } else {
                successRateOnFormatDate.get(dateFormatKeyAfterCheckPeriod).put("fail", (successRateOnFormatDate.get(dateFormatKeyAfterCheckPeriod).get("fail")) + 1);
            }
            LOGGER.log(Level.INFO, "successRateOnFormatDate: " + successRateOnFormatDate);


        }
        HashMap<String, Double> successRateMap = new HashMap<String, Double>();
        for (Map.Entry<String, HashMap<String, Integer>> entry : successRateOnFormatDate.entrySet()) {
                LOGGER.log(Level.INFO, "succes value on date: " + entry.getValue());
                LOGGER.log(Level.INFO, "key success rate: " + entry.getKey());
                if ((entry.getValue().get("success")+entry.getValue().get("fail")) == 0) {
                    successRateMap.put(entry.getKey(), 0.0);
                } else {
                    successRateMap.put(entry.getKey(),
                            Double.valueOf(entry.getValue().get("success"))/(entry.getValue().get("success")+entry.getValue().get("fail"))
                    );
                }
        }
        LOGGER.log(Level.INFO, "successRateMap: " + successRateMap);

        return successRateMap;
    }
}


\end{lstlisting}

Код BuildTestCountLogic.java:

\begin{lstlisting}
package io.jenkins.plugins.sample;

import hudson.model.AbstractProject;
import hudson.model.Result;
import hudson.model.Run;
import hudson.tasks.test.AbstractTestResultAction;
import hudson.tasks.test.AggregatedTestResultAction;
import hudson.util.RunList;
import java.text.ParseException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;


public class BuildTestCountLogic extends BuildLogic {

    static Logger LOGGER = Logger.getLogger(BuildTestCountLogic.class.getName());
    HashMap<String, Integer> testCountOnFormatDate;
    String dateFormatKey;

    public BuildTestCountLogic(IntervalDate period, RunList<Run> buildList) {
        super(period, true, buildList);
    }

    public Map<String, Integer> getTestCount() throws ParseException {
        filterPeriodBuild();
        filterPeriodBuild();
        switch (this.period) {
            case MONTH:
                testCountOnFormatDate = DateTimeHandler.createDateMonthMapTestCount();
                dateFormatKey = "yyyy-MM-dd";
                break;
            case WEEK:
                testCountOnFormatDate = DateTimeHandler.createDateWeekMapTestCount();
                dateFormatKey = "yyyy-MM-dd";
                break;
            case YEAR:
                testCountOnFormatDate = DateTimeHandler.createDateYearMapTestCount();
                dateFormatKey = "yyyy-MM";
                break;
            case QUARTER:
                testCountOnFormatDate = DateTimeHandler.createDateQuarterMapTestCount();
                dateFormatKey = "yyyy-MM";
                break;
            case DAY:
                testCountOnFormatDate = DateTimeHandler.createDateDayMapTestCount();
                dateFormatKey = "yyyy-MM-dd HH";
                break;
            case ALL:
                testCountOnFormatDate = DateTimeHandler.createDateDayMapTestCount();
                dateFormatKey = "yyyy-MM";
                break;
        }

        for (Run run : this.buildList) {
            LOGGER.log(Level.FINEST, "testCountMap: " + getTestCountForRun(run));

            String dateFormatKeyAfterCheckPeriod =
                    DateTimeHandler.dateToString(
                            DateTimeHandler.convertLongTimeToDate(
                                    run.getStartTimeInMillis()
                            ), dateFormatKey
                    );
            LOGGER.log(Level.INFO, "dateFormatKeyAfterCheckPeriod: " + dateFormatKeyAfterCheckPeriod);
            if (this.period == IntervalDate.DAY) {
                dateFormatKeyAfterCheckPeriod = DateTimeHandler.dateSetZeroMinutesSeconds(dateFormatKeyAfterCheckPeriod);
                LOGGER.log(Level.INFO, "dateFormatKeyAfterCheckPeriod for day zero: " + dateFormatKeyAfterCheckPeriod);
            }
            if (testCountOnFormatDate.get(dateFormatKeyAfterCheckPeriod) == 0) {
                testCountOnFormatDate.put(dateFormatKeyAfterCheckPeriod, getTestCountForRun(run));
                LOGGER.log(Level.WARNING, "getTestCountForRun: " + getTestCountForRun(run));

            } else {
                testCountOnFormatDate.put(dateFormatKeyAfterCheckPeriod, testCountOnFormatDate.get(dateFormatKeyAfterCheckPeriod) + getTestCountForRun(run));
            }
        }
        LOGGER.log(Level.INFO, "testCountOnFormatDate: " + testCountOnFormatDate);
        return testCountOnFormatDate;
    }


    public int getTestCountForRun(Run run) {
        int testCount = 0;
        List<AbstractTestResultAction> testActions = run.getActions(AbstractTestResultAction.class);
        for (AbstractTestResultAction testAction : testActions) {
            LOGGER.log(Level.INFO, "testAction: " + testAction);
            LOGGER.log(Level.INFO, "getPassedTests: " + testAction.getPassedTests());
            LOGGER.log(Level.INFO, "getPassedTests: " + testAction.getPassedTests().size());
            LOGGER.log(Level.INFO, "getFailedTests: " + testAction.getFailedTests());
            testCount+=testAction.getPassedTests().size();

        }

        return testCount;

    }
}



\end{lstlisting}

Код BuildTimeQueueLogic.java:

\begin{lstlisting}

package io.jenkins.plugins.sample;

import hudson.model.Run;
import hudson.util.RunList;
import org.apache.commons.math3.stat.StatUtils;
import org.apache.commons.math3.stat.descriptive.DescriptiveStatistics;
import org.apache.commons.math3.util.FastMath;

import java.text.ParseException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;

public class BuildTimeQueueLogic extends BuildLogic {
    static Logger LOGGER = Logger.getLogger(BuildDurationLogic.class.getName());

    HashMap<String, List<Double>> dateFormatDuration;
    String dateFormatKey;
    public BuildTimeQueueLogic(IntervalDate period, RunList<Run> buildList) {
        super(period, true, buildList);
    }

    public Map<String, Double> getTimeQueue(Statistics statistics) throws ParseException {
        filterPeriodBuild();

        switch (this.period){
            case MONTH:
                dateFormatDuration = DateTimeHandler.createDateMonthMap();
                dateFormatKey = "yyyy-MM-dd";
                break;
            case WEEK:
                dateFormatDuration = DateTimeHandler.createDateWeekMap();
                dateFormatKey = "yyyy-MM-dd";
                break;
            case YEAR:
                dateFormatDuration = DateTimeHandler.createDateYearMap();
                dateFormatKey = "yyyy-MM";
                break;
            case QUARTER:
                dateFormatDuration = DateTimeHandler.createDateQuarterMap();
                dateFormatKey = "yyyy-MM";
                break;
            case DAY:
                dateFormatDuration = DateTimeHandler.createDateDayMap();
                dateFormatKey = "yyyy-MM-dd HH";
                break;
            case ALL:
                dateFormatDuration = DateTimeHandler.createDateYearMap();
                dateFormatKey = "yyyy-MM";
                break;
        }


//        HashMap<String, Integer> dayDurationAverage = new HashMap<>();
        for (Run run : this.buildList) {
            String dateFormatKeyAfterCheckPeriod =
                    DateTimeHandler.dateToString(
                            DateTimeHandler.convertLongTimeToDate(
                                    run.getStartTimeInMillis()
                            ), dateFormatKey
                    );
            LOGGER.log(Level.INFO, "dateFormatKeyAfterCheckPeriod time Queue: " + dateFormatKeyAfterCheckPeriod);
            if (this.period == IntervalDate.DAY) {
                dateFormatKeyAfterCheckPeriod = DateTimeHandler.dateSetZeroMinutesSeconds(dateFormatKeyAfterCheckPeriod);
                LOGGER.log(Level.INFO, "dateFormatKeyAfterCheckPeriod for day zero: " + dateFormatKeyAfterCheckPeriod);
            }
            long runTimeInQueue = new TimeInQueueFetcher().getTimeInQueue(run);
//            if (dateFormatDuration.get(dateFormatKeyAfterCheckPeriod) == 0.0) {
//
//                LOGGER.log(Level.WARNING, "getTimeInQueue long: " + runTimeInQueue);
//                dateFormatDuration.put(dateFormatKeyAfterCheckPeriod,  (double) runTimeInQueue);
//                LOGGER.log(Level.WARNING, "getTimeInQueue double: " + (double) runTimeInQueue);
//                dayDurationAverage.put(dateFormatKeyAfterCheckPeriod, 1);
//            } else {
//                dateFormatDuration.put(dateFormatKeyAfterCheckPeriod, dateFormatDuration.get(dateFormatKeyAfterCheckPeriod) + (double) runTimeInQueue);
//                dayDurationAverage.put(dateFormatKeyAfterCheckPeriod, dayDurationAverage.get(dateFormatKeyAfterCheckPeriod) + 1);
//            }
            dateFormatDuration.get(dateFormatKeyAfterCheckPeriod).add((double) runTimeInQueue);
            LOGGER.log(Level.WARNING, "dateFormatDurationListValues: " + dateFormatDuration);
        }
//        if (average) {
//            for (Map.Entry<String, Integer> entry : dayDurationAverage.entrySet()) {
//                LOGGER.log(Level.INFO, "sum time queue: " + dateFormatDuration.get(entry.getKey()));
//                LOGGER.log(Level.INFO, "count runs time queue: " + entry.getValue());
//                dateFormatDuration.put(entry.getKey(),
//                        dateFormatDuration.get(entry.getKey())/entry.getValue()
//                );
//            }
//        }
        HashMap<String, Double> dayTimeQueueMetric = new HashMap<String, Double>();

        for (Map.Entry<String, List<Double>> entry : dateFormatDuration.entrySet()) {
            // work with one date array metric [1.2, 2.09, 5,09]
            DescriptiveStatistics descriptiveStatistics = new DescriptiveStatistics();
            for (double v : entry.getValue()) {
                descriptiveStatistics.addValue(v);
            }

            if (entry.getValue().size() == 0) {
                dayTimeQueueMetric.put(entry.getKey(), 0.0);
                continue;
            }

            switch (statistics){
                case SUM:
                    double sum = descriptiveStatistics.getSum();
                    LOGGER.log(Level.WARNING, "sum: " + sum);
                    dayTimeQueueMetric.put(entry.getKey(), sum);
                    break;
                case AVG:
                    double mean = descriptiveStatistics.getMean();
                    LOGGER.log(Level.WARNING, "mean: " + mean);
                    dayTimeQueueMetric.put(entry.getKey(), mean);
                    break;
                case RANGE:
                    double range = descriptiveStatistics.getMax() - descriptiveStatistics.getMin();
                    LOGGER.log(Level.WARNING, "range: " + range);
                    dayTimeQueueMetric.put(entry.getKey(), range);
                    break;
                case MEDIAN:
                    double median = descriptiveStatistics.getPercentile(50);
                    LOGGER.log(Level.WARNING, "median: " + median);
                    dayTimeQueueMetric.put(entry.getKey(), median);
                    break;
                case DISPERSION:
                    double dispersion = descriptiveStatistics.getPopulationVariance();
                    LOGGER.log(Level.WARNING, "sum: " + dispersion);
                    dayTimeQueueMetric.put(entry.getKey(), dispersion);
                    break;
                case SDUNBIASED:
                    double sdUnbiased = descriptiveStatistics.getStandardDeviation();
                    LOGGER.log(Level.WARNING, "sdUnbiased: " + sdUnbiased);
                    dayTimeQueueMetric.put(entry.getKey(), sdUnbiased);
                    break;
                case SD:
                    double sd = FastMath.sqrt(descriptiveStatistics.getPopulationVariance());
                    LOGGER.log(Level.WARNING, "sd: " + sd);
                    dayTimeQueueMetric.put(entry.getKey(), sd);
                    break;
                case MODE:
                    //prepare for mode with StatUtils methods
                    double[] doublesArray = entry.getValue().stream().mapToDouble(d -> d).toArray();
                    double[] modes = StatUtils.mode(doublesArray);
                    double mode;

                    if (modes.length == doublesArray.length) {
                        mode = 0;
                    } else {
                        mode = modes[0];
                    }

                    LOGGER.log(Level.WARNING, "mode: " + mode);
                    dayTimeQueueMetric.put(entry.getKey(), mode);
                    break;
            }


        }
        LOGGER.log(Level.INFO, "dayTimeQueueMetric time queue: " + dayTimeQueueMetric);
        //LOGGER.log(Level.INFO, "dayDurationAverage time queue: " + dayDurationAverage);
        return dayTimeQueueMetric;
    }
}






\end{lstlisting}

Код TimeInQueueFetcher.java:

\begin{lstlisting}

package io.jenkins.plugins.sample;

import hudson.model.Run;

import java.util.concurrent.TimeUnit;

public class TimeInQueueFetcher {
    public long getTimeInQueue(Run build) {
        long queuedTime = build.getStartTimeInMillis() - build.getTimeInMillis();
        return TimeUnit.MILLISECONDS.toMillis(queuedTime);
    }
}

\end{lstlisting}

Код dateIntervalEnum.java.java:

\begin{lstlisting}
package io.jenkins.plugins.sample;

enum IntervalDate {
    DAY,
    WEEK,
    MONTH,
    YEAR,
    QUARTER,
    ALL
}


\end{lstlisting}

Код Statistics.java:

\begin{lstlisting}
package io.jenkins.plugins.sample;

enum Statistics {
    SUM,
    AVG,
    MEDIAN,
    RANGE,
    DISPERSION,
    SD,
    SDUNBIASED,
    MODE
}



\end{lstlisting}

Код LinearRegressionHandler.java

\begin{lstlisting}
package io.jenkins.plugins.sample;

import org.apache.commons.math3.fitting.WeightedObservedPoints;
import org.apache.commons.math3.stat.regression.OLSMultipleLinearRegression;
import org.apache.commons.math3.stat.regression.SimpleRegression;

import java.util.Arrays;
import java.util.logging.Level;
import java.util.logging.Logger;

public  class LinearRegressionHandler {

    static Logger LOGGER = Logger.getLogger(LinearRegressionHandler.class.getName());

    static double linearRegression(double[] yUnweighted, double[] weights) {


        double[] y = new double[yUnweighted.length];
        double[][] x = new double[yUnweighted.length][2];

        for (int i = 0; i < y.length; i++) {
            LOGGER.log(Level.INFO, "yUnweighted i: " + yUnweighted[i]);
            LOGGER.log(Level.INFO, "weights i: " + weights[i]);
            y[i] = Math.sqrt(weights[i]) * yUnweighted[i];
            x[i][0] = Math.sqrt(weights[i]) * i + 1;
            x[i][1] = Math.sqrt(weights[i]);
            LOGGER.log(Level.INFO, "y[i]: " +y[i]);
            LOGGER.log(Level.INFO, "x[i][0]: " + x[i][0]);
        }

        OLSMultipleLinearRegression regression = new OLSMultipleLinearRegression();
        regression.setNoIntercept(true);
        regression.newSampleData(y, x);

        double[] regressionParameters = regression.estimateRegressionParameters();
        double slope = regressionParameters[0];
        double intercept = regressionParameters[1];

        double predictedValue = slope * (yUnweighted.length + 1)+ intercept;
        LOGGER.log(Level.INFO, "y = " + slope + "*x + " + intercept);
        LOGGER.log(Level.INFO, "predicted = " + predictedValue);
        return predictedValue;
    }

    public static double[] calculateWeightMetric(double[] arrMetricValues) {
        LOGGER.log(Level.INFO, "arrMetricValues: " + Arrays.toString(arrMetricValues));
        double averageMetric = Arrays.stream(arrMetricValues).average().orElse(Double.NaN);
        LOGGER.log(Level.INFO, "averageMetric: " + averageMetric);
        double initialWeight = 1.0;
        double stepWeight = initialWeight/(arrMetricValues.length *2);
        double[] arrWeights = new double[arrMetricValues.length];
        LOGGER.log(Level.INFO, "stepWeight: " + stepWeight);
        for (int i = arrMetricValues.length - 1; i >= 0; i--) {
            if (arrMetricValues[i] < 0.5 * averageMetric) {
                arrWeights[i] = 0;
            } else {
                arrWeights[i] = initialWeight;
            }

            initialWeight-=stepWeight;
        }
        return arrWeights;
    }

}




\end{lstlisting}

Код js файла с парсингом данных и визуализацией:

\begin{lstlisting}






var ctx = document.getElementById("successRateChart").getContext("2d");
var ctxBuild = document.getElementById("buildDurationChart").getContext("2d");
var ctxArtifactsSize = document.getElementById("artifactsSize").getContext("2d");
var ctxTimeSpentQueue = document.getElementById("timeSpentQueue").getContext("2d");
var ctxTestCount = document.getElementById("testCount").getContext("2d");


function typeChartHandler(typeChart, labels, title, dictValues){

  let data = {};
  let allPerf = {};
  switch(typeChart) {
      case 'Bar':
        data = {
                  labels: labels,
                  datasets: [{
                    label: title,
                    data: dictValues,
                    backgroundColor: [
                      'rgba(0, 255, 0, 0.5)',
                    ],
                    borderColor: [
                      'rgb(0, 69, 36)',
                    ],
                    categoryPercentage: 1,
                    borderWidth: 1,
                    barPercentage: 1,
                  }]
                };
       allPerf = {
                                type: 'bar',
                                data: data,
                                options: {
                                    scales: {
                                          y: {
                                            beginAtZero: true
                                          }
                                        },
                                    plugins: {
                                                legend: {
                                                    display: true,
                                                    labels: {
                                                        //color: 'rgb(255, 99, 132)',
                                                         font: {
                                                            size: 16,
                                                            weight: 'bold'
                                                         }
                                                    },

                                                }
                                            }

                                }
                              };

      break;
      case 'Line':
      data = {
        labels: labels,
        datasets: [{
          label: title,
          data: dictValues,
          borderColor: [
            'rgba(0, 180, 33, 1)',
          ],
          tension: 0.1

        }]
      };

      allPerf = {
                              type: 'line',
                              data: data,
                              options: {
                                      plugins: {
                                                                                      legend: {
                                                                                          display: true,
                                                                                          labels: {
                                                                                              //color: 'rgb(255, 99, 132)',
                                                                                               font: {
                                                                                                  size: 16,
                                                                                                  weight: 'bold'
                                                                                               }
                                                                                          },

                                                                                      }
                                                                                  }
                                  }

                            };


      break;

      case 'Radar':

            data = {
              labels: labels,
              datasets: [{
                label: title,
                data: dictValues,
                borderColor: [
                  'rgba(0, 180, 33, 1)',
                ],
                tension: 0.1

              }]
            };

            allPerf = {
                                    type: 'radar',
                                    data: data,
                                    options:  {
                                                     scale: {
                                                         min: 0
                                                     },
                                     plugins: {
                                                                                     legend: {
                                                                                         display: true,
                                                                                         labels: {
                                                                                             //color: 'rgb(255, 99, 132)',
                                                                                              font: {
                                                                                                 size: 16,
                                                                                                 weight: 'bold'
                                                                                              }
                                                                                         },

                                                                                     }
                                                                                 }
                                                 },
                                  };


      break;

  }

return allPerf;
}


function formatLabelsDate(arrLabels, dateFormat, period) {
switch(period) {
    case 'DAY':
                 arrLabels.push(
                            dateFormat.getDate()+
                                       " "+(dateFormat.getHours())+":0"+(dateFormat.getMinutes())

                       );
    break;
    case 'WEEK':
    case 'MONTH':
                 arrLabels.push(
                            dateFormat.getDate()+
                                       "/"+(dateFormat.getMonth()+1)+
                                       "/"+dateFormat.getFullYear()
                       );
    break;

    case 'QUARTER':
    case 'YEAR':
                 arrLabels.push(
(dateFormat.getMonth()+1)+"/"+dateFormat.getFullYear()
                       );

    break;

}
console.log("arrLabels", arrLabels);
}



function sortOnKeys(dict, period) {

    var sorted = [];
    for(var key in dict) {
        console.log("key", key);
        sorted[sorted.length] = key;
        console.log("sorted", sorted);
    }
    sorted.sort();
    console.log("sorted2", sorted);
    var dataBuildDurationValues = [];
    var labelsB = [];
    for(var i = 0; i < sorted.length; i++) {
       dataBuildDurationValues.push(dict[sorted[i]]);
       console.log("dataBuildDurationValues", dataBuildDurationValues, dict[sorted[i]]);
       var dateFormat= new Date(parseInt(sorted[i]));
       console.log("dateFormat", dateFormat);
       //var period = document.querySelector(".period").textContent;
       console.log("period", period)
       formatLabelsDate(labelsB, dateFormat, period);
       console.log("labelsB", labelsB);
    }
    return [dataBuildDurationValues, labelsB];
}

// success rate chart settings

var successRateSelect = document.querySelector("#selectSuccess");

function createSuccessRateChart(){
var period = document.getElementById("selectSuccess").value;
var typeChart = document.getElementById("selectChartSR").value;
console.log("period", period);
console.log("typeChart", typeChart)
var successRate2 = document.querySelector("#successRateData").textContent;
  console.log(successRate2);
  var obj = JSON.parse(successRate2);
  console.log("json", obj);

  var dataSuccessRateValues = [];
  var dataSuccessRateDict = {};
console.log(obj.count);
   for (var key in obj){
  console.log("111", key);


dataSuccessRateDict[Date.parse(key)] = parseFloat(obj[key]);
  }
  console.log("dataSuccessRateDict: ", dataSuccessRateDict);

  dictSuccess = sortOnKeys(dataSuccessRateDict, period)[0];
  labelsSuccess = sortOnKeys(dataSuccessRateDict, period)[1];

 let allPerf = typeChartHandler(typeChart, labelsSuccess, 'Success rate', dictSuccess);



  if (perfChartJsCharts["successRateChart"]) perfChartJsCharts["successRateChart"].destroy();
  perfChartJsCharts["successRateChart"] = new Chart(ctx, allPerf);

}


// test count chart settings

var testCountSelect = document.querySelector("#selectTestCount");

function createTestCountChart(){
var period = document.getElementById("selectTestCount").value;
var typeChart = document.getElementById("selectChartTC").value;
console.log("period", period)
var testCount2 = document.querySelector("#testCountData").textContent;
  console.log(testCount2);
  var obj = JSON.parse(testCount2);
  console.log("json", obj);

  var dataTestCountValues = [];
  var dataTestCountDict = {};
console.log(obj.count);
   for (var key in obj){
  console.log("111", key);


dataTestCountDict[Date.parse(key)] = parseFloat(obj[key]);
  }
  console.log("dataTestCountDict: ", dataTestCountDict);

  dictTestCount = sortOnKeys(dataTestCountDict, period)[0];
  labelsTestCount = sortOnKeys(dataTestCountDict, period)[1];

let settingsTestCount = typeChartHandler(typeChart, labelsTestCount, 'Test Count', dictTestCount);

  if (perfChartJsCharts["testCountChart"]) perfChartJsCharts["testCountChart"].destroy();
  perfChartJsCharts["testCountChart"] = new Chart(ctxTestCount, settingsTestCount);

}


// build duration chart settings

var buildDurationSelect = document.querySelector("#selectBuildDuration");

function createBuildDurationChart(){
var period = document.getElementById("selectBuildDuration").value;
var typeChart = document.getElementById("selectChartBD").value;
console.log("period", period)
var buildDuration = document.querySelector("#buildDurationData").textContent;
  console.log(buildDuration);
  var obj = JSON.parse(buildDuration);
  console.log("json", obj);

  var dataBuildDurationValues = [];
  var dataBuildDurationDict = {};
console.log(obj.count);
   for (var key in obj){
  console.log("111", key);
  console.log("Date.parse(key)", Date.parse(key));


dataBuildDurationDict[Date.parse(key)] = parseFloat(obj[key]);
  }
  console.log("dataBuildDurationDict: ", dataBuildDurationDict);

  dictBuildDuration = sortOnKeys(dataBuildDurationDict, period)[0];
  labelsBuildDuration = sortOnKeys(dataBuildDurationDict, period)[1];


   let settingsBuildDuration = typeChartHandler(typeChart, labelsBuildDuration, 'Build duration', dictBuildDuration);
  if (perfChartJsCharts["buildDurationChart"]) perfChartJsCharts["buildDurationChart"].destroy();
  perfChartJsCharts["buildDurationChart"] = new Chart(ctxBuild, settingsBuildDuration);

}



// artifact size chart settings

var artifactSizeSelect = document.querySelector("#selectArtifactSize");

function createArtifactSizeChart(){
var period = document.getElementById("selectArtifactsSize").value;
var typeChart = document.getElementById("selectChartAS").value;
console.log("period", period)
var artifactSize = document.querySelector("#artifactSizeData").textContent;
  console.log(artifactSize);
  var obj = JSON.parse(artifactSize);
  console.log("json", obj);

  var dataArtifactSizeValues = [];
  var dataArtifactSizeDict = {};
console.log(obj.count);
   for (var key in obj){
  console.log("111", key);
  console.log("Date.parse(key)", Date.parse(key));


dataArtifactSizeDict[Date.parse(key)] = parseFloat(obj[key]);
  }
  console.log("dataArtifactSizeDict: ", dataArtifactSizeDict);

  dictArtifactSize = sortOnKeys(dataArtifactSizeDict, period)[0];
  labelsArtifactSize = sortOnKeys(dataArtifactSizeDict, period)[1];

let settingsArtifactSize = typeChartHandler(typeChart, labelsArtifactSize, 'Artifact Size', dictArtifactSize);
  if (perfChartJsCharts["artifactSizeChart"]) perfChartJsCharts["artifactSizeChart"].destroy();
  perfChartJsCharts["artifactSizeChart"] = new Chart(ctxArtifactsSize, settingsArtifactSize);

}

// time queue chart settings

var timeQueueSelect = document.querySelector("#selectTimeQueue");

function createTimeQueueChart(){
var period = document.getElementById("selectTimeQueue").value;
var typeChart = document.getElementById("selectChartTQ").value;
console.log("period", period)
var timeQueue = document.querySelector("#timeQueueData").textContent;
  console.log(timeQueue);
  var obj = JSON.parse(timeQueue);
  console.log("json", obj);

  var dataTimeQueueValues = [];
  var dataTimeQueueDict = {};
console.log(obj.count);
   for (var key in obj){
  console.log("111", key);
  console.log("Date.parse(key)", Date.parse(key));


dataTimeQueueDict[Date.parse(key)] = parseFloat(obj[key]);
  }
  console.log("dataTimeQueueDict: ", dataTimeQueueDict);

  dictTimeQueue = sortOnKeys(dataTimeQueueDict, period)[0];
  labelsTimeQueue = sortOnKeys(dataTimeQueueDict, period)[1];

   let settingsTimeQueue = typeChartHandler(typeChart, labelsTimeQueue, 'Time Spent In Queue', dictTimeQueue);
  if (perfChartJsCharts["timeQueueChart"]) perfChartJsCharts["timeQueueChart"].destroy();
  perfChartJsCharts["timeQueueChart"] = new Chart(ctxTimeSpentQueue, settingsTimeQueue);

}













\end{lstlisting}

Код jelly файла, со взаимодействием Java, JS и интерфейса

\begin{lstlisting}
<?jelly escape-by-default='true'?>
<j:jelly xmlns:j="jelly:core" xmlns:l="/lib/layout" xmlns:st="jelly:stapler" xmlns:f="/lib/form">
        <head>
                <style>
                        label {
                                max-width:200px;
                        }
                        .buildDuration, .period,
                        .successRate, .timeQueue,
                        .artifactSize, .testCount, #successRateData, #buildDurationData,
                        #testCountData, #artifactSizeData, #timeQueueData
                        {
                                display:none;
                        }
                        .graph-container {
                        width: 95%;

                        }
                        .graph-block{
                                padding: 5px;
                                border: 1px solid grey;
                                margin: 10px;
                                display: flex;

                        }
                        .canvas-container{
                        width: 80%;

                        }
                        .settings{
                        padding: 5px;
                        width:210px;
                        margin: 10px;
                        display: flex;
                        flex-direction: column;

                        }
                        form label{
                        margin: 5px;
                        }

                </style>
        </head>


        <l:layout title="Build Configuration Statistics">

                <l:side-panel>
                        <st:include page="sidepanel.jelly" it="${it.job}" optional="true" />
                </l:side-panel>
                <l:main-panel>

                        <h1>Statistics for job ${it.job.name}</h1>

                        <div id="successRateData"></div>
                        <div id="buildDurationData"></div>
                        <div id="artifactSizeData"></div>
                        <div id="testCountData"></div>
                        <div id="timeQueueData"></div>

                        <script id="script1">

                                var myObjectBuild = <st:bind value="${it}"/>

                                myObjectBuild.getBuildSuccessRate('MONTH', function(t) {
                                document.getElementById('successRateData').innerHTML = t.responseObject();
                                createSuccessRateChart();
                                });
                                function myCheckSuccess(){
                                var strPeriod = document.getElementById("selectSuccess").value;
                                var typeChart = document.getElementById("selectChartAS").value;
                                console.log(strPeriod, "Day");
                                console.log(typeChart, "typeChart");
                                myObjectBuild.getBuildSuccessRate(strPeriod, function(t) {
                                document.getElementById('successRateData').innerHTML = t.responseObject();
                                createSuccessRateChart();
                                });

                                }


                                myObjectBuild.getBuildDuration('MONTH', '0', 'SUM', function(t) {
                                document.getElementById('buildDurationData').innerHTML = t.responseObject();
                                createBuildDurationChart();
                                });
                                function myCheckBuildDuration(){
                                var strPeriod = document.getElementById("selectBuildDuration").value;
                                var strStatistic = document.getElementById("selectStatisticBD").value;
                                var checkFailed = document.getElementById('checkboxFailedBuildDuration').checked ?  '1' : '0';

                                console.log(strPeriod, "strPeriod buildDuration");
                                console.log(strStatistic, "strStatistic buildDuration");
                                myObjectBuild.getBuildDuration(strPeriod, checkFailed, strStatistic, function(t) {
                                document.getElementById('buildDurationData').innerHTML = t.responseObject();
                                createBuildDurationChart();
                                });

                                }


                                myObjectBuild.getBuildArtifactSize('MONTH', '0', 'SUM', function(t) {
                                document.getElementById('artifactSizeData').innerHTML = t.responseObject();
                                createArtifactSizeChart();
                                });
                                function myCheckArtifactsSize(){
                                var strPeriod = document.getElementById("selectArtifactsSize").value;
                                var strStatistic = document.getElementById("selectStatisticAS").value;
                                var checkFailed = document.getElementById('checkboxFailedArtifactsSize').checked ?  '1' : '0';

                                console.log(strPeriod, "strPeriod ArtifactSize");
                                console.log(strStatistic, "strStatistic ArtifactSize");
                                myObjectBuild.getBuildArtifactSize(strPeriod, checkFailed, strStatistic, function(t) {
                                document.getElementById('artifactSizeData').innerHTML = t.responseObject();
                                createArtifactSizeChart();
                                });

                                }


                                myObjectBuild.getBuildTimeQueue('MONTH', 'SUM', function(t) {
                                document.getElementById('timeQueueData').innerHTML = t.responseObject();
                                createTimeQueueChart();
                                });
                                function myCheckTimeQueue(){
                                var strPeriod = document.getElementById("selectTimeQueue").value;
                                var strStatistic = document.getElementById("selectStatisticTQ").value;

                                console.log(strPeriod, "strPeriod TimeQueue");
                                console.log(strStatistic, "strStatistic TimeQueue");
                                myObjectBuild.getBuildTimeQueue(strPeriod, strStatistic, function(t) {
                                document.getElementById('timeQueueData').innerHTML = t.responseObject();
                                createTimeQueueChart();
                                });

                                }

                                myObjectBuild.getBuildTestCount('MONTH', '0', function(t) {
                                document.getElementById('testCountData').innerHTML = t.responseObject();
                                createTestCountChart();
                                });
                                function myCheckTestCount(){
                                var strPeriod = document.getElementById("selectTestCount").value;
                                var checkFailed = document.getElementById('checkboxFailedTestCount').checked ?  '1' : '0';

                                console.log(strPeriod, "strPeriod TestCount");
                                myObjectBuild.getBuildTestCount(strPeriod, checkFailed, function(t) {
                                document.getElementById('testCountData').innerHTML = t.responseObject();
                                createTestCountChart();
                                });

                                }



                        </script>

                        <div class="graph-container">
                        <div class="graph-block">
                                <div class="canvas-container">
                                <canvas id="successRateChart" width="90" height="25"></canvas>
                                </div>
                                <form class="settings">
                                        <label>

                                                Type chart:
                                                <select id="selectChartSR" onchange="createSuccessRateChart()">
                                                        <option value="Bar">Bar</option>
                                                        <option value="Line">Line trend</option>
                                                        <option value="Radar">Radar</option>
                                                </select>

                                        </label>
                                        <label>
                                                Range:
                                                <select id="selectSuccess" onchange="myCheckSuccess()">
                                                        <option value="MONTH">Month</option>
                                                        <option value="DAY">Day</option>
                                                        <option value="YEAR">Year</option>
                                                        <option value="WEEK">Week</option>
                                                        <option value="QUARTER">Quarter</option>
                                                        <option value="ALL">All</option>
                                                </select>

                                        </label>

                                </form>
                        </div>
                        <div class="graph-block">
                                <div class="canvas-container">
                                <canvas id="buildDurationChart" width="90" height="25"></canvas>
                                </div>
                                <form class="settings">
                                        <label>

                                                Type chart:
                                                <select id="selectChartBD" onchange="createBuildDurationChart()()">
                                                        <option value="Bar">Bar</option>
                                                        <option value="Line">Line trend</option>
                                                        <option value="Radar">Radar</option>
                                                </select>

                                        </label>
                                        <label>
                                                Range:
                                                <select id="selectBuildDuration" onchange="myCheckBuildDuration()">
                                                        <option value="MONTH">Month</option>
                                                        <option value="DAY">Day</option>
                                                        <option value="YEAR">Year</option>
                                                        <option value="WEEK">Week</option>
                                                        <option value="QUARTER">Quarter</option>
                                                        <option value="ALL">All</option>
                                                </select>



                                        </label>
                                        <label>

                                                Statistic:
                                                <select id="selectStatisticBD" onchange="myCheckBuildDuration()">
                                                        <option value="SUM">Sum</option>
                                                        <option value="AVG">Average</option>
                                                        <option value="MEDIAN">Median</option>
                                                        <option value="RANGE">Range</option>
                                                        <option value="DISPERSION">Dispersion</option>
                                                        <option value="SD">Standard Deviation</option>
                                                        <option value="SDUNBIASED">Standard Deviation Unbiased</option>
                                                        <option value="MODE">Mode</option>
                                                </select>

                                        </label>
                                        <label>
                                                Show failed:
                                                <input type="checkbox" id="checkboxFailedBuildDuration" onchange="myCheckBuildDuration()"/>
                                        </label>

                                </form>
                        </div>
                        <div class="graph-block">
                                <div class="canvas-container">
                                <canvas id="timeSpentQueue" width="90" height="25"></canvas>
                                </div>
                                <form class="settings">
                                        <label>

                                                Type chart:
                                                <select id="selectChartTQ" onchange="createTimeQueueChart()">
                                                        <option value="Bar">Bar</option>
                                                        <option value="Line">Line trend</option>
                                                        <option value="Radar">Radar</option>
                                                </select>

                                        </label>
                                        <label>
                                                Range:
                                                <select id="selectTimeQueue" onchange="myCheckTimeQueue()">
                                                        <option value="MONTH">Month</option>
                                                        <option value="DAY">Day</option>
                                                        <option value="YEAR">Year</option>
                                                        <option value="WEEK">Week</option>
                                                        <option value="QUARTER">Quarter</option>
                                                        <option value="ALL">All</option>
                                                </select>

                                        </label>
                                        <label>

                                                Statistic:
                                                <select id="selectStatisticTQ" onchange="myCheckTimeQueue()">
                                                        <option value="SUM">Sum</option>
                                                        <option value="AVG">Average</option>
                                                        <option value="MEDIAN">Median</option>
                                                        <option value="RANGE">Range</option>
                                                        <option value="DISPERSION">Dispersion</option>
                                                        <option value="SD">Standard Deviation</option>
                                                        <option value="SDUNBIASED">Standard Deviation Unbiased</option>
                                                        <option value="MODE">Mode</option>
                                                </select>

                                        </label>

                                </form>
                        </div>
                        <div class="graph-block">
                                <div class="canvas-container">
                                <canvas id="testCount" width="90" height="25"></canvas>
                                </div>
                                <form class="settings">

                                        <label>

                                                Type chart:
                                                <select id="selectChartTC" onchange="createTestCountChart()">
                                                        <option value="Bar">Bar</option>
                                                        <option value="Line">Line trend</option>
                                                        <option value="Radar">Radar</option>
                                                </select>

                                        </label>
                                        <label>
                                                Range:
                                                <select id="selectTestCount" onchange="myCheckTestCount()">
                                                        <option value="MONTH">Month</option>
                                                        <option value="DAY">Day</option>
                                                        <option value="YEAR">Year</option>
                                                        <option value="WEEK">Week</option>
                                                        <option value="QUARTER">Quarter</option>
                                                        <option value="ALL">All</option>
                                                </select>

                                        </label>
                                        <label>
                                                Show failed:
                                                <input type="checkbox" id="checkboxFailedTestCount" onchange="myCheckTestCount()"/>
                                        </label>

                                </form>
                        </div>
                        <div class="graph-block">
                                <div class="canvas-container">
                                <canvas id="artifactsSize" width="90" height="25"></canvas>
                                </div>
                                <form class="settings">
                                        <label>

                                                Type chart:
                                                <select id="selectChartAS" onchange="createArtifactSizeChart()">
                                                        <option value="Bar">Bar</option>
                                                        <option value="Line">Line trend</option>
                                                        <option value="Radar">Radar</option>
                                                </select>

                                        </label>
                                        <label>
                                                Range:
                                                <select id="selectArtifactsSize" onchange="myCheckArtifactsSize()">
                                                        <option value="MONTH">Month</option>
                                                        <option value="DAY">Day</option>
                                                        <option value="YEAR">Year</option>
                                                        <option value="WEEK">Week</option>
                                                        <option value="QUARTER">Quarter</option>
                                                        <option value="ALL">All</option>
                                                </select>

                                        </label>
                                        <label>

                                                Statistic:
                                                <select id="selectStatisticAS" onchange="myCheckArtifactsSize()">
                                                        <option value="SUM">Sum</option>
                                                        <option value="AVG">Average</option>
                                                        <option value="MEDIAN">Median</option>
                                                        <option value="RANGE">Range</option>
                                                        <option value="DISPERSION">Dispersion</option>
                                                        <option value="SD">Standard Deviation</option>
                                                        <option value="SDUNBIASED">Standard Deviation Unbiased</option>
                                                        <option value="MODE">Mode</option>
                                                </select>

                                        </label>
                                        <label>
                                                Show failed:
                                                <input type="checkbox" id="checkboxFailedArtifactsSize" onchange="myCheckArtifactsSize()"/>
                                        </label>

                                </form>
                        </div>
                        </div>

                </l:main-panel>
        </l:layout>
        <st:adjunct includes="io.jenkins.plugins.sample.BuildConfigurationStatisticsAction.declareChartJsClickArray"/>
        <st:adjunct includes="io.jenkins.plugins.sample.BuildConfigurationStatisticsAction.chartLogicBox"/>
</j:jelly>


\end{lstlisting}


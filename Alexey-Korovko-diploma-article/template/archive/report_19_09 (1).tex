\documentclass[a4paper,twoside,11pt]{article}
\usepackage[cp1251]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{fancyhdr}
\usepackage{newprog1e}
\usepackage{amsfonts,amsmath,amssymb,amsthm}
\usepackage{graphicx}
\usepackage{hyperref}

\tolerance=1000

\newcommand{\defi}{\stackrel{\mathrm{def}}{=}}

\numberwithin{equation}{section}
\newtheorem{theorem}{Теорема}

\newtheorem{definition}{Definition}
\newtheorem{theorem_ru}{Теорема}


\journalnumber{2}
\curyear{2024}
\authorlist{КУХТО И ДР.}
\titlehead{РАЗРАБОТКА ПЛАГИНА JENKINS ДЛЯ ВИЗУАЛИЗАЦИИ СТАТИСТИКИ ПО ПРОЦЕССУ СБОРКИ ПРОГРАММЫ.}
\headerdef

\udk{004.421.6}
%92+004.94}
\rubrika{ПРОГРАММНАЯ ИНЖЕНЕРИЯ, ТЕСТИРОВАНИЕ И ВЕРИФИКАЦИЯ ПРОГРАММ.}
\dateinput{10.07.2012}

\rusabstr{
}

\author{
{\bfseries А.~Д.~Кухто, В.~А.~Пархоменко, А.~В.~Щукин}
\\ {\itshape *Санкт-Петербургский политехнический университет Петра Великого
Институт компьютерных наук и кибербезопасности}
\\ {\slshape 195251} {\itshape Санкт-Петербург, Политехническая, ул., д. } {\slshape 29, 3-й учебный корпус, каб. 308 }
\\ {\itshape E-mail: kuhto.ad@edu.spbstu.ru, vladimir.parkhomenko@spbstu.ru,  Alexander.Schukin@spbstu.ru }}
\title{РАЗРАБОТКА ПЛАГИНА JENKINS ДЛЯ ВИЗУАЛИЗАЦИИ СТАТИСТИКИ ПО ПРОЦЕССУ
СБОРКИ ПРОГРАММЫ}
%\thanks{~}

\date{}

\begin{document}

\maketitle
\setcounter{page}{3}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\He{Введение}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Сегодня разработка информационных систем достаточно сложный процесс, который состоит, как правило, из следующих основных этапов: анализ требований заказчика, проектирование системы, разработка, тестирование и доставка приложения потенциальному заказчику. 

Для упрощения процесса разработки программного обеспечения в настоящий момент широко применяются практики DevOps, одной из которых является непрерывная интеграция, сборка и доставка (Continuous Integration, Continuous Delivery, далее --- CI/CD) \cite{cidef}. Существует множество средств CI/CD, которые применяются в промышленной разработке: TeamCity, Jenkins, Gitlab CI и другие.

Под \textit{сборкой программного продукта} будем подразумевать процесс объединения отдельных файлов и компонентов программы в единый исполняемый файл или пакет, который включает в себя компиляцию, связывание модулей, оптимизацию и другие операции, необходимые для создания готового к выполнению приложения \cite{build}.

Будем различать понятие сборки программного продукта и \textit{сборки} в инструментах CI/CD, таких как Jenkins, которые обычно используются \textit{командой для совместной работы над одним проектом}. \textit{Сборка Jenkins} — это набор задач, которые выполняются последовательно, как определено пользователем \cite{jenkinsjob}.

Одним из лучших средств CI/CD, в котором доступно много функций ''из коробки'' является TeamCity компании Jetbrains. TeamCity - мощный и сложный инструмент, который использовался крупными ИТ компаниями в промышленной разработке до 2022 года. Одним из главных недостатков TeamCity является то, что это платное решение, лицензия обходится ИТ компания достаточно дорого, также недостатком является то, что компания Jetbrains покинула ИТ сектор РФ. Для того, чтобы преодолеть данные проблемы ИТ компании РФ начали поиск бесплатных средств с открытым исходным кодом. Одним из таких средств является Jenkins - средство CI, которое всегда пользовалось популярностью у разработчиков при локальной разработке решений с открытым исходным кодом. 

Jenkins обладает меньшим функционалом по сравнению с TeamCity, но имеет много подключаемых плагинов, которые могут помочь заменить или даже улучшить те функции, которые требуется разработчикам в процессе тестирования, сборки и доставки приложений.

\textbf{Актуальность исследования.} На данный момент в Jenkins нет плагина, который полностью заменяет модуль визуализации статистики (Statistics) из TeamCity. Этот плагин/модуль требуется для того чтобы отслеживать состояние отдельных конфигураций сборки с течением времени, плагин собирает статистические данные по всей истории сборки и отображает их в виде наглядных диаграмм.

\textbf{Степень разработанности проблемы.} Среди имеющихся плагинов Jenkins есть те, которые реализует частичный функционал модуля из TeamCity, например, отображение графика продолжительности сборок за период. Подробнее о недостатках таких средств будет описано в сравнительном анализе и обзоре аналогов. 

\textbf{Объект исследования} — средства для сборки приложений в инструментах совместного использования.

\textbf{Предмет исследования} — визуализация статистики по процессу сборки программы.

\textbf{Цель} - разработать плагин Jenkins для визуализации статистики по процессу сборки программы. % в инструментах совместного использования.

Задачи:
 
\begin{enumerate}
	\item Изучить инструменты сборки приложений.
	
	\item Изучить особенности CI/CD, Jenkins, работу и характеристики сборок Jenkins.
	
	\item Описать метрики и статистики, которые могут собираться по результатам работы сборок Jenkins.
	
	\item Изучить методы разработки плагинов Jenkins.
	
	\item Провести проектирование плагина и описать архитектуру.
	
	\item Реализовать плагин.
	
	\item Провести тестирование и апробацию плагина. 
	
\end{enumerate}

Основными \textbf{методами} проведения работы являются методы сравнительного анализа аналогичных решений и методы объектно-ориентированного программирования.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\He{АНАЛИЗ СРЕДСТВ СБОРКИ ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ}
\label{resob}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\he{Инструменты сборки программного обеспечения}

Для осуществления сборки программного продукта существует множество инструментов, какое средство использовать определяют не только из преимуществ и недостатков этих средств, но и исходя из того, какой используется язык программирования, фреймворк и окружение.
На данный момент существует большое количество инструментов сборки приложения. 

Maven — инструмент для автоматизации сборки проектов, который используется с Java приложениями.

Gradle — система автоматизации сборки, которая также часто используется для Java разработки.

Для проектов на JavaScript для управления зависимостями и сборками может использоваться npm в связке с Webpack.

Также необходимо отметить, что в отличии от компилируемых языков, таких как Java, приложения на интерпретируемом языке Python могут запускаться без сборки прямо из командной строки, а для управления зависимостями в Python используется инструмент pip.

Существуют также и другие инструменты сборки для приложений написанных на разных языках программирования. Все их удобно использовать при локальной разработке над небольшими проектами, но когда рассматривается вопрос о разработке большого продукта, в работе над которым задействуется целая команда разработчиков и тестировщиков, для уменьшения затрат на разработку, в первую очередь временных, следует внедрять DevOps практики и CI/CD подходы.

Инструменты CI/CD позволят взаимодействовать с репозиторием гита, проводить сборку продукта автоматически по заданному времени или по наличию новых коммитов, прогонять тесты после каждого изменения разработчика, производить установку на различные стенды, а также выполнять сборку различных компонентов системы одновременно и доставлять продукт заказчику. Перейдем к рассмотрению особенностей CI/CD инструментов, а затем рассмотрим сравнение их между собой.


\he{Анализ средств CI/CD} 


CI/CD — это технология автоматизации тестирования и доставки/развертывания готового приложения заказчику  \cite{cicd}. Данная технология стала неотъемлемой составляющей DevOps методологии и помогает сократить временные  ресурсные затраты в процессе современного жизненного цикла приложения, когда до заказчика изначально доходит минимально жизнеспособный продукт (MVP), а затем дорабатывается с учетом новых требований заказчика, т.е. идет непрерывная разработка новых версий продукта.

Преимущества CI/CD подхода \cite{plusci}:

\begin{itemize}
	\item упрощение разработки - позволяет разработчикам распределять приоритеты и сконцентрироваться на самых важных аспектах;
	\item улучшение качества кода -  качество кода проверяется до того, как он достигнет среды тестирования, проблемы в коде могут быть выявлены на ранних стадиях;
	\item более короткие циклы тестирования - меньший объем кода для проверки, становиться проще определить проблемы в процессе развертывания;
	\item более простой мониторинг изменений - меньший объем кода для проверки;
	\item более легкий откат - меньшие усилия для отката приложения к предыдущей версии при возникновении проблем в новой версии.
\end{itemize}



На данный момент существует множеств инструментов CI/CD, которые обладают своими преимуществами и недостатками, были выделены самые распространенные системы.

Jenkins — это автономный сервер автоматизации с открытым исходным кодом, который можно использовать для автоматизации всех видов задач, связанных со сборкой, тестированием, доставкой или развертыванием программного обеспечения.

TeamCity - это сервер CI от компании Jetbrains, который позволяет запускать параллельные сборки одновременно на разных платформах и средах, а также настраивать статистику по продолжительности сборки, уровню успешности, качеству кода и пользовательским метрикам.

GitLab CI - сервер CI от компании GitLab, которая также предоставляет одноименный репозиторий Git. GitLab CI/CD может обнаруживать ошибки на ранних этапах цикла разработки и гарантировать, что весь код, развернутый в рабочей среде, соответствует установленным стандартам кода.

CircleCI - сервер CI, который позволяет настроить для эффективной работы очень сложных конвейеров кэширование, кэширование уровня Docker и классы ресурсов для работы на более быстрых машинах.

Bamboo — это инструмент непрерывной интеграции и доставки, который связывает автоматизированные сборки, тесты и выпуски в единый рабочий процесс.

При сравнении особое внимание следует уделить критерию OpenSource, этот критерий является достаточно важным с учетом, того, что многие компании после 2022 года ушли из РФ, тем самым стали либо недоступны, либо прекратили лицензировании и стали менее безопасными, т.к. новые версии продуктов больше недоступны и проблемы с безопасностью и другими дефектами не будут исправлены/доступны на территории РФ. Также критерий важен тем, что даже при наличии действия продуктов компаний, они обходилось крупным ИТ-компаниям достаточно дорого.

Также необходимо отметить еще 2 критерия для более объективной оценки: интеграции - количество интеграций инструмента со сторонними средствами и встроенная функциональность - количество встроенных функций.
Критерий интеграция показывает сколько можно подключить к системе плагинов и интеграций со сторонними сервисами, а встроенный функционал сколько функций из коробки поддерживает, то или иное средство, наличие инструментов, которые позволят облегчить работу.

Если сравнивать описанные выше средства, то TeamCity обладает самой мощной встроенной функциональностью, а также достаточно большим количеством интеграций и плагинов \cite{cianalyze}, в сравнении со всеми остальными инструментами, за исключением Jenkins.

Jenkins в отличие от перечисленных коммерческих средств обладает самой низкой встроенной функциональностью, также отсутствует возможность построения конвейеров, но при этом все эти недостатки закрываются большим количеством плагинов, которые постоянно пишутся разработчиками, среди плагинов имеется и pipeline, который и нужен для построения конвейеров, количество плагинов около 2 тысяч, что в несколько раз больше, чем у TeamCity, в котором около 500 плагинов и интеграций.

Среди всех средств особо ярко выделяется Jenkins, поскольку он является бесплатным и с открытым исходным кодом, а также обладает большим количество интеграций и плагинов, которые постоянно пишутся, что позволяет устранить основной его недостаток по наличию встроенных функций.
 
 
\he{Анализ существующих плагинов Jenkins по визуализации статистики процесса сборки} 

Поскольку для работы со сборками приложений был выбран Jenkins, то разработка плагина будет производиться в этой системе. В любой системе с большим количеством приложений, сборок и тестов будет удобно производить мониторинг и визуализацию информации по статистике работы сборок во времени. 

Под статистикой работы сборок будем понимать следующие статистические характеристики собираемых метрик (продолжительность исполнения сборки, время проведенное в очереди сборкой, размеры полученных по итогам сборки артефактов): среднее арифметическое, мода, медиана, размах, среднеквадратическое отклонение, среднеквадратическое отклонение несмещенное, дисперсия.

Для оценки плагинов, необходимо понять какие метрики требуется для сбора статистики работы сборок. Требуется реализовать следующие метрики:

\begin{itemize}
	\item визуализация метрики \textit{Success Rate} (далее ---~SR) - процент успешности сборок, который будет показывать сколько сборок завершилось успешно;
	\item визуализация метрики  \textit{Build Duration} (далее ---~BD) - время выполнения сборок, в том числе должен быть доступен фильтр на добавления в график упавших сборок, а также возможность вычислять не только суммарно время сборок, а также среднее время всех сборок за определенный интервал времени;
	\item визуализация метрики  \textit{Time Spent in queue} (далее ---~TQ) - время проведенное в очереди сборок, в том числе среднее время, вычисляемое аналогично Build Duration;
	\item  визуализация метрики  \textit{Test Count} (далее ---~TC) - количество выполненных тестов в сборке, в том числе количество выполненных тестов в упавших сборках, если таковые успели выполниться;
	\item визуализация метрики  \textit{Artifacts Size} (далее ---~AS) - размер созданных во время сборок артефактов, в том числе средний размер за определенный интервал времени, а также учет артефактов, которые успели создаться в сборках до падения.
\end{itemize}

Сначала рассмотрим уже разработанные плагины визуализации и их недостатки и преимущества в сравнении с разрабатываемым решением. Результаты сравнения приведены в табл.1.

\begin{table*}
    \centering
    \caption{Сравнительный анализ плагинов Jenkins}
    \begin{tabular}{|p{5cm}|p{2cm}|p{3cm}|p{2cm}|p{3cm}|}
    \hline
        Критерий & Build Monitor Plugin & Global Build Stats Plugin & Build Time Blame & Разрабатыва-\linebreak емый плагин  \\ \hline
        Прогнозирование метрик следующей сборки  & - & - & - & +  \\ \hline
        Открытый исходный код  & + &+ & + & +  \\ \hline
        Визуализация времени выполнения и статуса последней сборки & + &+ & - (только время) &+  \\ \hline
        Визуализация SR истории сборок & - & +/- (в TeamCity гистограммы, которые показывают процентное соотношение нагляднее) & - & +  \\ \hline
       Визуализация BD истории сборок (в числе average) & - & + & +  & +  \\ \hline
       Визуализация TQ & - & - & -  &+  \\ \hline
      Визуализация TC & - & - & +  & +  \\ \hline
      Визуализация AS & - &- &-  & +  \\ \hline
       Отображение всех графиков на одной странице по одному диапазону времени для наглядного отображения всех метрик в один момент и во времени & - & + & -  & +  \\ \hline
    \end{tabular}
\end{table*}	

 Build Monitor Plugin - плагин, который обеспечивает наглядное представление статуса выбранных заданий Jenkins.
 
 Global Build Stats Plugin - плагин, который позволит собирать и отображать глобальную статистику результатов сборки, а также позволяющий отображать глобальную тенденцию сборки Jenkins/Hudson с течением времени.
 
  Build Time Blame - плагин, который сканирует вывод консоли на наличие успешных сборок и генерирует отчет, показывающий, как эти шаги повлияли на общее время сборки.
  
  После проведения сравнения аналогичных решений, были выявлены преимущества разрабатываемого плагина, которые обосновывают его разработку, это отсутствие у данных плагинов функционала по визуализации Artifacts Size, Time Spent in queue, Success Rate истории сборок, а также наличие прогнозирования метрик следующей сборки. Также данные плагины не предлагают динамическое изменение графиков по мере изменения временного интервала или установления фильтров.

\he{Требования к разработке}

Поскольку разрабатываемый плагин является аналогом модуля статистики сборок в TeamCity (поскольку TeamCity является лучшим из коммерческих инструментов и имеет удобный модуль визуализации статистики), то функционал должен как минимум реализовывать функции модуля Statistics в TeamCity. В первую очередь должна производиться визуализация метрик сборок с помощью графиков и диаграмм.

На всех графиках и диаграммах должна быть возможность выбора значения из выпадающего списка интервала времени, за который будет производиться сбор статистики за день, месяц, квартал, неделю, год.

\textit{Например}, если был выбран промежуток времени месяц, то должен выполняться следующий набор действий:

\begin{enumerate}
	\item Должна собираться информация о требуемой метрики у всех сборок.
	
	\item Производиться фильтрация сборок т.е. должны отбираться только сборки за последний месяц (в том числе упавшие, если был выбран данный чекбокс).
	
	\item Полученные сборки должны группироваться по дням т.е. на итоговом графике должно быть 30/31 точка или столбца.
	
	\item Если необходимо производиться вычисление статистической обработки среди всех сгруппированных за день метрик сборок.
	
	\item Отображение всей информации о метриках сборки на одном графике или диаграмме.
	
	
\end{enumerate}

Также все графики должны располагаться друг под другом на одной странице, что может наглядно показать (если на каждом графике был выбран один период), все вычисленные метрики за один период, например при выборе месяца все перечисленные метрики будут отображены на странице и можно будет увидеть, что происходило, например вчера по результатам запуска всех сборок.

По метрикам BD, AS, TQ должна быть возможность выбрать статистический показатель, в соответствии с которым должна производить обработка итоговых значений. Возможные показатели перечислены в разделе 2.3.

Помимо прочего требуется, чтобы при визуализации можно было выбрать различные типы диаграмм: столбчатые, линейные тренды, круговые.

Также было принято решения добавить анализ данных, чтобы делать предположение, о том какими метриками будет обладать следующая запущенная сборка, при вычислении данного значения должно быть рассчитаны веса каждой сборки/сборок по графику за определенный период, и если сборка была собрана, например, месяц назад - она должна иметь меньший вес, чем сборка, собранная вчера.

Также к разработке будет предъявлено требование об удобстве интерфейса: все графики должны быть удобными, не перегруженными информацией, а также интерфейс должен быть интуитивно понятно, чтобы данный плагин не усложнял восприятие собранной статистики сборок и не вызывал желание воспользоваться другим плагином или разработать другой более удобной, или отказаться от идеи смотреть статистику по сборкам.

\he{Выводы}

По всем описанным выше разделам можно прийти к выводу, что данный плагин актуален для ИТ-компаний, которые ранее отдавали предпочтению многофункциональному инструменту TeamCity, в котором уже были все необходимые для работы функции, особенно это актуально для компаний в РФ, но также может понадобиться и другим компания, которые приняли решение отказаться от TeamCity в пользу Jenkins из-за больших денежных затрат на лицензию. Также будет реализованы дополнительный функционал по сравнению с модулем TeamCity, что даст преимущества не только в цене. После проведенного обзора аналогичных решений становится понятно, что сейчас в Jenkins нет полнофункциональной замены модуля статистики TeamCity, также необходимо учесть и визуальную составляющую, чтобы при установке данного плагина разработчики выбирали его не только из-за отсутствия другого решения.

%-------------------------------------

\He{ПРОЕКТИРОВАНИЕ АРХИТЕКТУРЫ ПЛАГИНА}

\he{Модель системы}

Диаграмма вариантов использования, показывающая функционал плагина отображена на рис.1. На данной диаграмме основное внимание также уделяется процессу визуализации статистики метрик сборок. Основное действующее лицо одно - это пользователь системы, который запускает сборки и работает в CI системе, это может быть любой участник команды, который задействован в разработке, тестировании, доставке и внедрению приложения. В данном случае все эти роли представлены на диаграмме как разработчик.

\begin{figure*}[ht!] 
	\center
	\includegraphics [scale=0.7] {my_folder/images//usecase3}
	\caption{Use case } 
	\label{fig:usecase3}  
\end{figure*}

Функциональная модель в нотации  archimate отображена на рис.2. Основное внимание на диаграмме уделяется визуализации статистики сборок, поскольку это изначально является целью разработки. Также там будут отражены дополнительные функции такие как фильтрация, и высчитывание статистик метрик.

\begin{figure*}[ht!] 
	\center
	\includegraphics [scale=0.7] {my_folder/images//Fmod}
	\caption{Процесс визуализации сборок} 
	\label{fig:er1}  
\end{figure*}

\he{Архитектура Jenkins}

Перед объяснением построения архитектуры плагинов Jenkins, необходимо привести описание архитектуры Jenkins, где будет отображено место разрабатываемых плагинов в CI системе. Установленные плагины Jenkins-CI, а также локальные сценарии и приложения выполняются на сервере Jenkins-CI и предоставляют расширяемый набор функций управления и обработки данных \cite{article}.




Архитектура плагинов использует точки расширения, которые, предоставляют разработчикам плагинов возможности реализации для расширения функциональности системы Jenkins \cite{atchplugin}. Точки расширения автоматически обнаруживаются Jenkins во время загрузки системы.

В разрабатываемом плагине реализация будет происходить через класс Action. Actions являются основным строительным блоком расширяемости в Jenkins: их можно прикреплять ко многим объектам модели, хранить вместе с ними и при необходимости добавлять в их пользовательский интерфейс.

Помимо класса Action для того чтобы создать временные действия, которые будут прикреплены к заданию Jenkins будет использован класс TransientActionFactory, который позволяет создавать действия, которые будут отображаться на страницах Jenkins только при наличии соответствующего объекта - задания.

Разработка будет выполняться в объектно-ориентированной парадигме, т.е. приложение будет разбито на классы, будет применяться наследование, полиморфизм и инкапсуляция. Все классы, которые будут разработаны для плагина отображены на рис.3. 

\begin{figure*}[ht!] 
	\center
	\includegraphics [scale=0.8] {my_folder/images//class3}
	\caption{Диаграмма классов плагина} 
	\label{fig:class3}  
\end{figure*}

При рассмотрении диаграммы необходимо отметить, что два класса являются встроенными в Jenkins, это TransientActionFactory, который позволяет добавлять действия к любому типу объекта, а также интерфейс Action - добавленный к объекту модели, создает дополнительное подпространство URL-адресов под родительским объектом модели, через которое он может взаимодействовать с пользователями. Actions также способны открывать доступ к левому меню в интерфейсы Jenkins, по которому обычно производится навигация при конфигурировании сборки.

Для удобства использования плагина, предполагается добавить дополнительную ссылку в меню слева, для перехода на страницу визуализации метрик, а также динамически обновлять страницу при изменении параметров и фильтров, что и обосновывает использование данных встроенных классов.

Основная часть остальных классов требуется для работы с определенной метрикой статистики выполнения сборок Jenkins, что следует из их названия. Также будет разработан дополнительный класс DateTimeHandler, который позволит создать методы для удобной работы с датой и временем, что необходимо поскольку будет производиться преобразования одних типов дат к другим, сравнение дат между собой, а также получение определенных частей дат.

\he{Архитектура плагина}

Для того чтобы визуализировать и обработать данные о сборках, необходимо получить эти данные. Для этого необходимо использовать различные методы и классы Jenkins, такие как Job - для работы с проектом (статическая сущность), а также Run для работы со сборкой (конкретные запуски Job, со временем выполнения и результатом). Внутри методов этих сущностей при их вызове будет отправляться API запрос на сервер Jenkins, который будет возвращать данные из хранилища xml файлов для каждой конкретной сборки.

После получения данных в плагине, идет их обработка и подготовка структур данных для визуализации. Вызов методов обработки данных о сборках будут происходить из Jelly файлов, в которых с помощью специальных тегов будет производиться связывание между объектами бизнес-логики Java и JS файлами, где будут создаваться графики визуализации.

Jelly для получения данных из Java использует AJAX запросы, а затем полученные данные сохраняет в DOM структуре страницы плагина. Затем с помощью JS происходит получение данных о сборках из DOM структуры и отправка в методы построения графиков.

Все взаимодействие между Java, Jelly и JS происходит с помощью JSON структур, такое решение было принято ввиду удобства работы со структурой с помощью этих инструментов. На рис.4 представлено изображение архитектуры плагина.

\begin{figure*}[ht!] 
	\center
	\includegraphics [scale=0.7] {my_folder/images//archi}
	\caption{Архитектура плагина} 
	\label{fig:ArchitecturePlugin}  
\end{figure*}


\he{Языки программирования}

Для программирования плагина будет использоваться язык Java. Поскольку Jenkins написан на Java, то все плагины необходимо писать на том же языке. Это является главным минусом, а возможно и сложностью при разработке плагинов на Jenkins, поскольку ограничивает свободу разработчика.

Есть возможность разработки плагина с использованием языка программирования Groovy. Недостатком такого выбора является то, что абсолютное большинство плагинов написано на чисто Java, а значит сообщества и поддержка при разработке на Java будет значительно большей. Также в сравнении с Groovy, Java обладает большей производительностью \cite{groovyvsjava}, статической типизацией и подходит для разработки приложений в парадигме ООП.

Java будет использоваться для программирования ядра плагина и бизнес-логики. Также для программирования графических компонентов, графиков и диаграмм будет использоваться язык программирования JavaScript. Основное предназначение JS - выполнять сценарии на веб-страницах, что необходимо при разработке плагина, результаты которого отображаются на веб-страницах.

Помимо прочего, для стилизации компонентов веб-интерфейса будет использоваться язык каскадных таблиц стилей CSS, который позволит настроить удобное отображение и позиционирование элементов на странице плагина Jenkins. 

Верстка страниц будет осуществляться с помощью инструмента Jelly - все разрабатываемые плагины используют данный инструмент в Jenkins, поскольку с ним можно легко интегрировать Java, XML и JS. Jelly — это средство для преобразования XML в исполняемый код, это механизм сценариев и обработки на основе Java и XML. В Jelly можно вызывать функции Java, использовать такие синтаксические конструкции, как циклы, условия и переменные, также он позволяет легко обратиться к объектам в Java.

\he{Инструменты сборки}

В качестве инструмента сборки проекта был выбран Maven, который можно использовать для создания и управления любым проектом на основе Java.

Абсолютное большинство разработанных плагинов для Jenkins использует Maven, поскольку Maven предоставляет удобные архетипы для начала разработки плагинов, что делает использование того же Gradle не рациональным.


\he{Библиотеки}


Поскольку проект предполагает использование графиков и диаграмм, то необходимо было выбрать инструмент для работы с графиками в Jenkins и Java, который позволит отображать графики прямо на странице задания Jenkins. В качестве этого инструмента была выбрана библиотека Chart.js, которая на данный момент является самой популярной JavaScript библиотекой по оценкам GitHub и загрузок npm.


Для удобства разработки и взаимодействия клиентской части с серверной необходимо, чтобы обработанные данные из Jenkins в браузер передавались в формате JSON. Для обеспечения преобразования объектов и структур Java в JSON была использована библиотека Gson от компании google.


Поскольку одним из требований к плагину является работа с математической статистикой для обработки метрик сборок, а также прогнозирование значений метрик, то необходима библиотека, которая реализует данный функционал. В качестве такой библиотеки была выбрана Apache Commons Math. Commons Math это библиотека легких, автономных математических и статистических компонентов, решающая наиболее распространенные проблемы, связанные со статистикой.


Для того чтобы, протестировать разработанный плагин, будут написаны unit тесты. Поскольку разработка плагина будет вестись на языке Java, то для написания тестов будет использована Java инструмент. В качестве такого инструмента был выбран Junit.


Поскольку функционал плагина использует обращение к структурам Jenkins (Job, Run), для тестирования необходимо использовать заглушки этих структур. Для работы с заглушками была выбрана библиотека mockito.

\he{Выводы}

В данном разделе было проведено проектирование плагина, составлена use-case диаграмма и диаграмма классов, построена функциональная модель системы, описана архитектура Jenkins, а также описана архитектура, разрабатываемого плагина. Затем были выбраны инструменты разработки плагина.


%-----------------------------------

\He{РЕАЛИЗАЦИЯ ПРОТОТИПА ПЛАГИНА}

\he{Описание разработанных классов} 

В процессе написания кода плагины были запрограммированы классы в соответствии с диаграммой классов из раздела 3.

\textbf{BuildConfigurationStatisticsAction}. Основной класс приложения, который реализует интерфейс действия, через этот класс происходит взаимодействие с Jelly, а также вызов всех остальных методов бизнес-логики плагина, и определены поля для работы со сборками, все методы для получения информации о конкретной метрике сборки помечены аннотацией @JavaScript для того, чтобы можно было их вызывать через JS в Jelly, также во всех этих методах тип возвращаемого объекта приведен к JSON, который и передается в DOM страницы плагина при взаимодействии с элементами пользовательского интерфейса.


\textbf{DateTimeHandler}. Статический класс, созданный для взаимодействия с датами и их обработки при создании структур данных, которые также создаются в рамках этого класса, формирования структуры данных зависит от метрики и от периода за который нужно получить информацию.
	
	\textbf{IntervalDate}. Перечисляемый тип для удобства работы с датами-периодами.

	\textbf{Statistics}. Перечисляемый тип для удобства работы с показателями статистики. 

\textbf{TimeInQueueFetcher}. Класс отвечающий за расчет времени, которая сборка провела в очереди перед тем как отправилась на выполнение. В классе определен один метод long getTimeInQueue(Run build) с помощью которого вычисляется нахождение времени в очереди в миллисекундах для конкретного запуска сборки.

\textbf{BuildLogic}. Базовый класс бизнес-логики, от которого наследуются все остальные более специфичные классы по каждой метрике, в классе определяются методы фильтрации по периоду и наличию упавших сборок в итоговых результатах. 

\textbf{BuildArtifactSizeLogic}. Класс для работы с метрикой AS, в нем происходит пересчет параметров в зависимости от периода и настроек подданных на вход, а также высчитывается размер артефакта в Кб. 

\textbf{BuildDurationLogic}. Класс для работы с метрикой BD, в нем происходит пересчет параметров в зависимости от периода и настроек подданных на вход, а также высчитывается продолжительность сборки в секундах. 

\textbf{BuildSuccessRateLogic}. Класс для работы с метрикой SR, в нем происходит пересчет параметров в зависимости от периода, а также высчитывается процент успешности выполненных сборок за заданный промежуток времени. 

\textbf{BuildTestCountLogic}. Класс для работы с метрикой TS, в нем происходит пересчет параметров в зависимости от периода и настроек подданных на вход, а также высчитывается количество выполненных тестов во время работы сборок за определенный период. 

\textbf{BuildTimeQueueLogic}. Класс для работы с метрикой TQ, в нем происходит пересчет параметров в зависимости от периода и настроек подданных на вход, а также высчитывается время ожидание сборки в очереди в миллисекундах. 

\textbf{LinearRegressionHandler}. Класс для прогнозирования метрик следующей сборки с помощью линейной регрессии с весовыми коэффициентами. 

\textbf{Файлы JS и Jelly}. В JS определяются функции событий для выбора элемента из выпадающего списка и взаимодействия с флажками. Для каждой метрики используется своя функции, внутри определяются настройки данных и отображения для визуализации отдельной метрики в виде определенного графика/диаграммы, вызывается метод для сортировки агрегированных по датам значений метрик в структуре JSON, а также формируются метки-подписи для каждого типа периода.


В jelly файле с помощью html формируется структура документа, а также выполняется привязка Java объектов к объектам JS. Определяются обработчики событий, который при взаимодействии с пользователем вызывают определенный запрос-метод AJAX.

\he{Результаты разработки плагина}

При разработке плагина надо было учитывать, что требуется отображать все графики на одной странице задания друг под другом, поскольку при выборе одно периода, например, месяца, будет получена сводная информация по каждой сборке или нескольких сборок запущенных в один день. Графики отображаются посредством переходна на соответствующую ссылку, оставляя при этом пользователя в том же задании (странице с результатами последних сборок). Интерфейс страницы плагина с графиками в системе Jenkins на странице задания показан на рис.5.


\begin{figure*}[ht!] 
	\center
	\includegraphics [scale=0.47] {my_folder/images//ui12}
	\caption{Интерфейс плагина Jenkins} 
	\label{fig:ui1}  
\end{figure*}


При взаимодействии с раскрывающимся списком должен вызываться Java метод, который пересчитает и отфильтрует необходимые сборки Jenkins и динамически отобразит результаты по выбранными периоду, также динамически должна производить обработка метрик сборок, при выборе статистического показателя, а также включение в графики данных об упавших сборках, при выборе соответствующих чекбоксов.
 
\he{Выводы}

В разделе была проведена реализация плагина, а также описаны классы, разработанные при написании плагина и файлы, которые участвуют во взаимодействии с этими классами и отображаемым интерфейсом пользователя. Также были приведены результаты разработки, приведены скриншоты интерфейсов.

%-----------------------------------

\He{ТЕСТИРОВАНИЕ И АПРОБАЦИЯ ПЛАГИНА В JENKINS} \label{ch4}


\he{Методы тестирования}

Тестирование программного обеспечения — обширное понятие, которое включает планирование, проектирование и, собственно, выполнение тестов  \cite{testing}. В процессе CI/CD производится непрерывное тестирование разработанного кода, а также тестирование разработанного приложения. Сам плагин является частью CI/CD процессе, но также требует тестирования корректной работы своей функциональности, тестирование разработанного кода, а также тестирования на соответствие исходным требования, которые были предъявлены к разработке в разделе 2.

Существует множество методов тестирования и техник тест дизайна, в процессе анализ функциональных требования были отобраны те, которые наиболее релевантные для разработанного плагина Jenkins.

Будет проведено как ручное, так и автоматизированное тестирование плагина. Ручное тестирование поможет выявить нетипичные тест-кейсы, которые не покрываются автоматизированными тестами.

\textbf{Unit тестирование}. Для запуска тестов требуется перейти в корень директории плагина и выполнить команду mvn test.

Код юнит тестов расположен в классе BuildConfigurationStatisticsBuilderTest. В этом классе проводятся проверки, такие как:

\begin{itemize}
	\item проверка корректности системы в целом - testWorkingSystem();
	\item проверка успешного завершения сборки - testSuccessBuildFromCustomBuild();
	\item проверка падения сборки при некорректных входных данных - testFailBuildFromCustomBuild();
	\item проверка формирования структур для начальной инициализации данных - testCreateDateWeekMapSuccessRate(), testCreateDateMonthMap();
	\item проверки корректности написанных методов работы с датой - testDateMonthToString(), testGetLastMonthDays();
	\item проверка работоспособности модулей обработки времени сборок - testGetTimeInQueue().
\end{itemize}

\textbf{BDD тестирование}. Помимо юнит тестов, были написаны автоматизированные тесты с использование методологии Behavior-driven development (BDD) или разработки через поведение. В соотвествии с BDD тесты следует писать на естественном, удобочитаемом языке, ориентированном на поведение приложения \cite{bdd}.

Для написания BDD тестов использовался фреймворк Cucumber, использующий Gherkin нотацию для описания сценария тество на естественном языке, а также заглушки для структур Jenkins.

Тесты написанные с BDD подходом, проверяют работоспособность основного функционала плагина, а именно получения обработонной информации по метрикам сборок, в соотвествии с указаныыми настройками/фильтрами пользователя.

\textbf{UI тестирование}. Также для автоматизации тестирования UI части плагина, был применен Selenium web driver и язык программирования python. Данные тест-кейсы будут в автоматическом режиме проверять реакцию элементов веб интерфейса на действия пользователя. Для запуска тестов требуется перейти в корень проекта Selenium и запустить команду pytest, при необходимости указать браузер и url, с которыми необходимо запустить UI тесты.

Код UI тестов расположен в отдельном проекте в классе TestCase. В этом классе проводятся проверки, такие как:

\begin{itemize}
	\item проверка корректности открытия и наличия элементов во вкладке на странице плагина - test\_open\_tab(self);
	\item проверка наличия и корректного отображения графика SR - test\_success\_rate\_chart(self);
	\item проверка наличия и корректного отображения графика BD - test\_build\_duration\_chart(self);
	\item проверка наличия и корректного отображения графика TC - test\_test\_count\_chart(self);
	\item проверка наличия и корректного отображения графика BQ - test\_time\_spent\_queue\_chart(self);
	\item проверка наличия и корректного отображения графика AS - test\_artifacts\_size\_chart(self);
	\item проверка корректности реакция элемента выпадающего списка - test\_change\_value\_select\_period(self);
	\item проверка  корректности реакция чекбоксов - test\_change\_value\_checkbox(self).
\end{itemize}


 \he{Апробация плагина}
 
 Апробация плагина будет проводится в системе CI Jenkins для которой и был разработан плагин визуализации. Для того чтобы провести апробацию плагина на локальном сервере Jenkins, запущенном на локальном или удаленном ПК, потребуется произвести несколько операций. Для начала, нужно будет клонировать репозиторий с кодом плагина на GitHub, перейти в папку проекта и выполнить \cite{deployplugin} Maven mvn install и скопировать .hpi в папку /plugins/. 
 
 Затем потребуется на запущенном сервере Jenkins перейти в Управление Jenkins  и среди доступных плагинов выбрать Build Configuration Statistics, установить, после чего напротив каждой сборки Jenkins в боком меню, откуда можно запустить и отредактировать сборку, появится пункт меню Build Configuration Statistics, при нажатии на которой должны отобразиться все графики с собранной статистикой по метрикам каждого задания в Jenkins. 
 
 
 Для того чтобы графики отображали какие-то данные, необходимо сначала сгенерировать сборки разной длительности, статусов, с разным количеством тестов и размером артефактов.
 
Для генерации запусков сборки, можно задать конфигурацию сборки через меню Configuration, а затем с помощью действия Build Now в меню сборки, запустить сборку на выполнение. Также можно использовать плагин Pipeline, для того чтобы декларативно с помощью groovy скрипта задать конфигурацию сборки с шагами, которые будут выполнять при запуске сборки. 


Для того чтобы проверить корректность обработки данных во времени, можно после запуска сборки, отредактировать (в логах выбранного запуска в папке запуска в файле build.xml) xml теги   <timestamp>1684077728000</timestamp> и
  <startTime>1684077728013</startTime> , в которых в формате timestamp задать нужное время в прошлом. Для конвертации даты и времени в timestamp можно использовать веб-ресурс https://www.epochconverter.com/.
  
Например, для даты Sunday, May 14, 2023 3:22:08 PM получаем следующий результат в формате timestamp 1684077728000 в миллисекундах. После редактирования xml файла с информацией о сборке получим необходимое дату  и время в интерфейсе Jenkins.

 
 В ходе апробации плагина были сгенерированы сборки, которые отображены на рис.6.
 
 \begin{figure}[ht!] 
	\center
	\includegraphics [scale=0.47] {my_folder/images//builds}
	\caption{Сгенерированные сборки} 
	\label{fig:builds}  
\end{figure}

Запуски были сгенерированы с разной датой начала:

\begin{itemize}
	\item 5 успешных запусков с датой 24.12.2023, с разным временем начала с 2 до 9 часов вечера;
	\item 1 успешный запуск 4.01.2024;
	\item 3 запуска 5.01.2024 - 2 из которых закончилось с результатом падение (в 0 часов и 23 часа), а один с положительным результатом в 23 часа;
	\item 11 запусков 7.01.2024 из которых 7 закончилось падением, а 4 с успешным результатом, запуски имеют разное время начала с 1 до 21 часа;
	\item 2 запуска 11.01.2024 один из которых закончился падением с временем начала 14 часов, а другой с успешным результатом в 14 часов;
	\item 2 успешных запуска 12.01.2024 со временем начала 13 часов и 16 часов.
\end{itemize}


 Среди сборок присутствуют, упавшие сборки со специально завышенным временем выполнения 100 секунд, сборки без завышенного времени выполнялись около 20 секунд.

А также сборки, с созданными артефактами, часть из которых в статусе успешного выполнения, с короткой продолжительностью, а часть из которых завершены падением с большой продолжительностью выполнения. Были определены разные файлы-артефакты для генерации с размером от 70 байт до 1 Кб. Перенос созданных файлов в артефакты выполнялся с помощью конфигурационного разделы в сборке Post-build Actions, в котором выплавлялась команда Archive the artifacts.



Часть сборок выполнялось посредством созданного класса в плагине BuildConfigurationStatisticsBuilder, который добавлял еще один вариант запуска шагов сборки Build Steps. Этот класс выполнял вывод информации о текущес запуске в консоль, а также вывод информации с именами всех запусков, уже выполненных в сборке, а также вывод параметра, который задавался при создании шага в конфигурации сборки.



Для части сборок был добавлен 1 шаг с выполнением cmd команды  \textit{echo 123}, для создания упавших сборок, команды cmd намеренно прописывались с ошибками в синтаксисе, например  \textit{echo1 123}.

Для того чтобы увеличить время выполнения сборок использовалась команда cmd  \textit{waitfor SomethingThatIsNeverHappening /t 100  2>NUL}, которая обеспечивала время выполнения запуска 100 секунд.

Для создания небольших файлов-артефактов использовалась команда cmd \textit{echo "tempbuild1111111111111111111"  1>tembuild.txt}. А для генерация файлов в 1Кб команда \textit{fsutil file createnew tem.txt 1048576}.

Для того, чтобы убедиться, что плагин работает также на уже существующих проектах, необходимо провести апробацию на стороннем проекте. В качестве такого проекта был выбран frontend-maven-plugin (https://github.com/eirslett/frontend-maven-plugin). 

Это плагин, который загружает/устанавливает Node и NPM локально для вашего проекта, запускает npm install, а затем любую комбинацию Bower , Grunt , Gulp , Jspm , Karma или Webpack и может работать в Windows, OS X и Linux \cite{frontplugin}. Этот продукт используется для:

\begin{itemize}
	\item разделения фронтенд и бекенд сборок, сводя количество взаимодействия между ними до минимума;
	\item использовать Node.js и его библиотеки в процессе сборки без глобальной установки Node/NPM;
	\item позволяет убедиться, что запущенные версии Node и NPM одинаковы в каждом окружении сборки.
\end{itemize}

У проекта 865 форков на GitHub, а также более 4 тысяч звезд, из чего следует, что его разработка была полезна для ИТ сообщества и активно используется разработчиками.

Следуя, указаниям из документации для сборки проекта необходимо вызвать команду \textit{mvn clean install}. В случае тестирования разработанного плагина  в системе Jenkins, также использовался ключ -l, который сохранит логи сборки проекта в отдельный файл clean. Также в настройках сборки Jenkins было настроено действие после сборки для создания артефакта из полученных логов.

Для моделирования ситуации просмотра статистики по метрикам сборки в условиях разных версий продукта, когда вносятся значительные изменения в код, что влечет за собой увеличния, в возможно и уменьшения (в случаи оптимизации) времени сборки продукта, необходимо откатиться к более ранним коммитам. Поскольку для апробации используется открытый проект, то данные манипуляции с исходным кодом возможно выполнить. Для того чтобы откатиться к предыдущим версиям, были проделаны следующие действия:

\begin{enumerate}
	\item Сделать fork проекта в личный репозиторий.
	
	\item Найти подходящий коммит, в котором были выполнены значительные изменения (более 500 строк измененного кода).
	
	\item Откатиться до найденного коммита.
	
	\item Создание новой ветки на основе коммита, до которого произошел откат.
	
	\item Отправка ветки в личный удаленный репозиторий на GitHub.
	
\end{enumerate}

После того как произведен откат до выбранного коммита, необходимо повторить процедуру начиная с коммита, до которого был произведен откат. Процедура была повторена 12 раз т.е. было сгенерировано 12 версий проекта на 12 месяцев года (для генерации сборок на год).

Для отката к более ранним версия был написан скрипт на языке Python.

Далее при генерации сборок было произведено по 2 запуска на каждую версию продукта, время в каждой сборке было отредактировано на каждый месяц за прошедший год. Для редактирования времени запуска сборки был написан скрипт на языке Python, который обрабатывает xml файлы с информацией о сборках. Перед выполнением каждого запуска был отредактирован параметр, по которому определяется из какой ветки берется исходный код продукта.

\textit{При формировании графиков на апробируемом проекте, даты запуска сборок были отредактированы по месяцам года (одна версия - один месяц), а не по реальным датам коммитов в репозитории. Рекомендуется смотреть на этап жизненного цикла продукта и проводить визуализацию по кварталам или месяцам.}


Результаты работы плагина на описанном выше проекте отображены на рис.7-8. На рис.7 видно на графике SR, как менялся процент успешности сборок в течении года на столбчатой диаграмме. Также видно на графике BD динамику изменения продолжительности сборок за последний год на линейном графике, в данном случае можно отследить как менялось среднее значение продолжительности. Видно, что время сборки незначительно увеличивалось, т.е. при увеличении кода приложения, в продолжительности сборки также увеличивалось время, за исключением 8 и 11 месяцев. 


 \begin{figure*}[ht!] 
	\center
	\includegraphics [scale=0.47] {my_folder/images//reares1}
	\caption{Результаты апробации на реальном проекте SR, BD} 
	\label{fig:reares1}  
\end{figure*}

В 8 месяце в изменениях кода была повышена версия npm и node, что оптимизировало время выполнения сборки, которое уменьшилось с 19.3 до 18.3 секунд. А версия в 11 месяце, вероятно была не протестировано перед загрузкой в главную ветку, поскольку результат из 3 запусков сборки закончился падением. Что также видно на графике SR, т.е. можно сделать вывод что в коммите был дефект, а не оптимизация, которая ускорила время сборки в несколько раз.

На рис.8 можно увидеть с помощью радарной диаграммы общий размер, сгенерированных логов-артефактов за последний год. Видно, что с каждым месяцем размер артефактов увеличивался, что также можно объяснить увеличением исходного кода продукта, также наглядна видно разницу между первым и последним месяцем года, а также то что при отображении упавших сборок видно, то что генерировались артефакты, хоть и с небольшим размером.

 \begin{figure*}[ht!] 
	\center
	\includegraphics [scale=0.47] {my_folder/images//realres2}
	\caption{Результаты апробации на реальном проекте AS} 
	\label{fig:realres2}  
\end{figure*}

По описанным выше результатам визуализации можно прийти к выводу, что плагин полезен тем, что отображает изменение различных метрик запусков сборки с течением времени, т.е. можно увидеть тенденцию изменений в созданных сборках Jenkins в течении цикла разработки за нужный период времени и если метрики в какой момент изменили свои значения, можно определить, что это за момент (или период) и проанализировать как изменения в сборке, тестах или коде могли повлиять на это.

Для удобства пользователей, как видно на рисунках выше, результаты отображаются на разных типах диаграмм, чтобы каждой участник команды мог изучать динамику изменения метрик, так как ему удобно. Также видно, что возле метрик BD, SR, AS можно выбрать статистический показатель, в соответствии с которым будут обработана метрика. Тем самым, можно определить является отклонение случайностью, нестабильностью сборки или это какая-то закономерность.

После анализа разработчики, тестировщики и DevOps-инженеры могут принять решение, насколько критичны данные изменения для процессов CI/CD и если потребуется оптимизировать сборки, тесты или, возможно, какую-то часть кода.

Также по данным диаграммам можно обнаружить и другие проблемы, например, аномалии в процессах сборки или тестирования или окружении, в котором производится сборка или установка компонентов системы.
 
 Для того чтобы оценить результаты работы, будет проведено сравнение функционала, который присутствует в аналогичных решениях: плагинах, сравнительный анализ, которых проводился в разделе 2.3 и модуль Statistics, реализованный в средстве CI TeamCity, который и послужил причиной для создания аналогичного модуля в Jenkins.
 

В разработанном плагине реализовано 7 статистических показателей, которые применяются к метрикам сборок, что является значительным преимуществом в сравнении с аналогичными решениями, поскольку в аналогичных плагинах Jenkins, а также в модуле TeamCity реализован только расчет среднего арифметического значения, и при том не во всех аналогичных плагинах Jenkins.

Также преимуществом разработанного плагина является наличие 3 типов диаграмм для каждой метрики, что больше чем у всех аналогичных решений. Все результаты сравнения с аналогичными решениями приведены в табл.2.

 \begin{table*}
    \centering
    \caption{Количественные результаты работы}
    \begin{tabular}{|p{3cm}|p{3cm}|p{2cm}|p{2cm}|p{2cm}|p{2cm}|}
    \hline
        Критерий & Разработанное решение & TeamCity & Build Monitor Plugin & Global Build Stats Plugin  & Build Time Blame \\ \hline
        Количество визуализируемых метрик & 5 & 5 & 1 & 2 &2 \\ \hline
        Количество статистических показателей & 7 & 1 & 0 & 1 &1\\ \hline
        Количество типов диаграмм & 3 & 2 & 1 & 1 &1\\ \hline


    \end{tabular}
\end{table*}

Если сравнивать по количеству визуализируемых метрик, то видно, что все 5 метрик, которые были реализованы в TeamCity, удалось реализовать и в разработанном плагине, аналогичные плагины Jenkins визуализируют определенные из перечисленных в разделе 2.3 метрик, но их количество меньше 5.


 
 
\he{Выводы}

По описанным в разделе результат, можно прийти к выводу, что тестирование проведено успешно. Апробация протестированного плагина, дала понять, что плагин корректно отрабатывает при разных поданных на вход исходных данных и настройках. Корректно высчитываются и визуализируются статистические показателе обработанных метрик.

Визуализация метрик со статистическими показателями была проверена на различных типах диаграмм/графиков: столбчатая диаграмма, линейный тренд, радарная диаграмма.

В результате разработки автоматизированных тестов было разработано 22 юнит теста, 2 BDD теста и 8 UI тестов.

Работоспособность плагина проверена на проекте открытым с исходным кодом frontend-maven-plugin. В ходе апробации были получено 24 запуска сборок на 12 разных версий продукта, в том числе 2 упавших запуска на одной из версий. Также было написано 2 python скрипта для формирования окружения для апробации.

Плагин рекомендуется использовать для:

\begin{itemize}
	\item прогнозирования метрик будущих сборок за выбранный период для планирования и оптимизации процесса разработки;
	\item отслеживания тенденций по изменению метрик сборки за период, в том числе выявления аномальных значений (резкое увеличение времени сборок и размера артефактов после добавления нового кода);
	\item по отслеженным данным можно определить узкие места в процессе сборки и оптимизировать этот процесс для ускорения развертывания;
	\item по отслеженным данным можно оценить эффективность CI/CD процесса, с целью улучшения процесса поставки;
	\item по отслеженным данным можно оценить качество кода и эффективности тестов и принять решения по улучшению этого качества.
\end{itemize}










%-----------------------------------


\He{ЗАКЛЮЧНИЕ}

В результате проведенной работы был разработан прототип плагина для визуализации статистики сборок Jenkins. Была проанализирована предметная область, проведен сравнительный анализ аналогичных решений.

Были выбраны средства и инструменты разработки, спроектирована архитектура плагина, описаны функциональные возможности, а также разработан программный код и интерфейс плагина.

В процессе проектирования и реализация были выбраны статистические показатели и типы диаграмм, по которым должна происходить визуализация метрик сборок Jenkins. Было проведено тестирование плагина различными методами и апробация на реальном проекте frontend-maven-plugin (более 4 тысяч звезд и 863 форка).

Плагин рекомендуется использовать для оценки эффективности написанного кода и тестирования, а также для оптимизации и улучшения процессов CI/CD, разработки и тестирования.

По итогу реализации объем кода проекта составляет $\sim$3220 строк, из которых:

\begin{itemize}
	\item $\sim$1680 строк  - Java код на сервере Jenkins;
	\item $\sim$780 строк - Jelly и JS на клиентской части;
	\item $\sim$260 строк - Java unit тесты;
	\item $\sim$210 строк - Java bdd тесты;
	\item $\sim$180 строк - Python код UI тестов;
	\item $\sim$85 строк - python скрипты для апробации.
\end{itemize}







%\begin{thebibliography}{99}
%
%\small
%\bibitem{AZ97}
%{\em Абрамов С.А., Зима Е.В.} Семинар по компьютерной алгебре на
%факультете вычислительной математики и кибернетики МГУ в 1995--1996 г.
%// Программирование, 1997,
%No 1. С. 75--77.
%
%\bibitem{AZ98}
%{\em Абрамов С.А., Зима Е.В.} Научно-ис\-сле\-до\-вательский семинар
%``Компьютерная алгебра'' в 1996--1997 г.
%// Программирование, 1998,
%No 1. С. 69--72.
%
%\bibitem{AR99}
%{\em Абрамов С.А., Ростовцев В.А.} Семинар по компьютерной алгебре в
%1997--1998 г.  // Программирование, 1998, No 6. С. 3--7.
%
%\bibitem{AKR00}
%{\em Абрамов С.А., Крюков А.П., Ростовцев В.А.} Семинар по компьютерной
%алгебре в
%1998--1999 г.  // Программирование, 2000, No 1. С. 8--12.
%
%\bibitem{AKR01}
%{\em Абрамов С.А., Крюков А.П., Ростовцев В.А.} Семинар по компьютерной
%алгебре
%в 1999--2000 г.  // Программирование, 2001, No 1. С. 3--7.
%
%\bibitem{AKR02}
%{\em Абрамов С.А., Крюков А.П., Ростовцев В.А.} Семинар по компьютерной
%алгебре в 2000--2001 г.  // Программирование, 2002, No 2. С. 6--9.
%
%\bibitem{AKR03}
%{\em Абрамов~С.А., Крюков~А.П., Ростовцев~В.А.} Семинар по компьютерной
%алгебре в 2001--2002 г. // Программирование, 2003, No 2. С. 3--7.
%\bibitem{AER04}
%{\em Абрамов~С.А., Еднерал~В.Ф., Ростовцев~В.А.} Семинар по
%компьютерной алгебре в 2002--2003~г.  // Программирование, 2004, No 2.
%С. 3--7.
%\bibitem{ABRE05}
%{\em Абрамов~С.А., Боголюбская~А.А., Ростовцев~В.А., Еднерал~В.Ф.} Семинар по
%компьютерной алгебре в 2003--2004 г.  // Программирование, 2005, No 2.
%С. 3--9.
%\bibitem{ABRE06}
%{\em Абрамов~С.А., Боголюбская~А.А., Ростовцев~В.А., Еднерал~В.Ф.} Семинар по
%компьютерной алгебре в 2004--2005 г.  // Программирование, 2006, No 2.
%С. 3--7.
%\bibitem{ABRE07}
%{\em Абрамов~С.А., Боголюбская~А.А., Ростовцев~В.А., Еднерал~В.Ф.} Семинар по
%компьютерной алгебре в 2005--2006 г.  // Программирование, 2007, No 2.
%С. 3--8.
%\bibitem{ABRE08}
%{\em Абрамов~С.А., Боголюбская~А.А., Ростовцев~В.А., Еднерал~В.Ф.} Семинар по
%компьютерной алгебре в 2006--2007 г.  // Программирование, 2008, No 2.
%С. 3--8.
%\bibitem{ABRE09}
%{\em Абрамов~С.А., Боголюбская~А.А., Ростовцев~В.А., Еднерал~В.Ф.} Семинар по
%компьютерной алгебре в 2007--2008 г.  // Программирование, 2009, No 2.
%С. 3--9.
%\newpage
%\bibitem{mmcp09}
%``Mathematical Modeling and Computational Physics (CAAP'2009)''. Book of abstracts of the internationl conference. Dubna, July 7-11, 2009.
%Dubna, 2009.
%\bibitem{ABRE10}
%{\em Абрамов~С.А., Боголюбская~А.А., Ростовцев~В.А., Еднерал~В.Ф.} Семинар по
%компьютерной алгебре в 2008-2009 г.  // Программирование, 2010, No 2. С. 3--8.
%\bibitem{ABER11}
%{\em Абрамов~С.А., Боголюбская~А.А., Еднерал~В.Ф., Ростовцев~В.А.} Семинар по
%компьютерной алгебре в 2009-2010 г. // Программирование, 2011, No 2. С. 3--8.
%\bibitem{ABR12}
%{\em Абрамов~С.А., Боголюбская~А.А.,  Ростовцев~В.А.} Семинар по
%компьютерной алгебре в 2010-2011 г.  // Программирование, 2012, No 2. С. 3--10.
%
%%
%
%\end{thebibliography}

%\label{lastpage}


\bibliographystyle{unsrt} % стиль цитат
\bibliography{my_biblio} % вместо bibliography нужно указать название вашего .bib файла без расширения (т.е. тут будет использован файл "bibliography.bib")

\end{document}






